{"version":3,"sources":["webpack:///webpack/bootstrap 6f0c3521ebd09b09579a","webpack:///./elements/demos/src/ListBox.js","webpack:///./elements/elix-mixins/src/ChildrenContentMixin.js","webpack:///./elements/elix-mixins/src/content.js","webpack:///./elements/elix-mixins/src/microtask.js","webpack:///./elements/elix-mixins/src/symbols.js","webpack:///./elements/elix-mixins/src/Symbol.js","webpack:///./elements/elix-mixins/src/ClickSelectionMixin.js","webpack:///./elements/elix-mixins/src/ContentItemsMixin.js","webpack:///./elements/elix-mixins/src/toggleClass.js","webpack:///./elements/elix-mixins/src/DirectionSelectionMixin.js","webpack:///./elements/elix-mixins/src/KeyboardDirectionMixin.js","webpack:///./elements/elix-mixins/src/KeyboardMixin.js","webpack:///./elements/elix-mixins/src/KeyboardPagedSelectionMixin.js","webpack:///./elements/elix-mixins/src/defaultScrollTarget.js","webpack:///./elements/elix-mixins/src/KeyboardPrefixSelectionMixin.js","webpack:///./elements/elix-mixins/src/constants.js","webpack:///./elements/elix-mixins/src/SelectionAriaMixin.js","webpack:///./elements/elix-mixins/src/SelectionInViewMixin.js","webpack:///./elements/elix-mixins/src/ShadowTemplateMixin.js","webpack:///./elements/elix-mixins/src/SingleSelectionMixin.js","webpack:///./elements/demos/src/MediaDeviceList.js","webpack:///./elements/demos/src/SingleSelectionDemo.js"],"names":["mixins","base","reduce","cls","mixin","HTMLElement","ListBox","attributeName","oldValue","newValue","mapAttributeToProperty","propertyName","itemSelected","item","selected","classList","toggle","defaults","orientation","value","changed","getAttribute","setAttribute","raiseChangeEvents","event","CustomEvent","dispatchEvent","template","customElements","define","ChildrenContentMixin","ChildrenContent","contentChanged","shadowCreated","slots","shadowRoot","querySelectorAll","forEach","slot","addEventListener","content","assignedChildren","assignedChildNodes","assignedTextContent","filterAuxiliaryElements","element","expandAssignedNodes","children","childNodes","strings","map","child","textContent","join","elements","auxiliaryTags","filter","call","Element","localName","indexOf","nodes","ElementsOnly","expanded","Array","prototype","isSlot","HTMLSlotElement","node","assignedNodes","flatten","flattened","concat","result","microtask","callbacks","document","createTextNode","counter","callback","push","executeCallbacks","length","shift","observer","MutationObserver","observe","characterData","symbols","getItemText","goDown","goEnd","goLeft","goRight","goStart","goUp","itemAdded","itemsChanged","keydown","count","uniqueString","description","symbolFunction","window","Symbol","ClickSelectionMixin","ClickSelection","button","target","path","itemForTarget","selectionRequired","console","warn","selectedItem","stopPropagation","listElement","items","itemCount","i","contains","ContentItemsMixin","itemsSymbol","itemInitializedSymbol","ContentItems","toggleClass","className","force","addClass","add","remove","DirectionSelectionMixin","DirectionSelection","selectNext","selectLast","selectPrevious","selectFirst","KeyboardDirectionMixin","KeyboardDirection","handled","horizontal","vertical","keyCode","metaKey","altKey","KeyboardMixin","Keyboard","preventDefault","tabindex","KeyboardPagedSelectionMixin","KeyboardPagedSelection","pageUp","pageDown","scrollOnePage","scrollTarget","getIndexOfItemAtY","y","downward","start","end","step","topOfClientArea","offsetTop","clientTop","itemIndex","itemTop","found","itemBottom","offsetHeight","itemStyle","getComputedStyle","itemPaddingTop","parseFloat","paddingTop","itemPaddingBottom","paddingBottom","contentTop","contentBottom","clientHeight","edge","scrollTop","indexOfItemAtEdge","selectedIndex","newIndex","delta","defaultScrollTarget","querySelector","getScrollingParent","root","overflowY","parentNode","KeyboardPrefixSelectionMixin","itemTextContentsSymbol","typedPrefixSymbol","prefixTimeoutSymbol","settingSelectionSymbol","KeyboardPrefixSelection","resetTypedPrefix","resetPrefix","handleBackspace","ctrlKey","which","handlePlainCharacter","String","fromCharCode","prefix","index","getIndexOfItemWithTextPrefix","itemTextContents","getItemTextContents","prefixLength","itemTextContent","substr","text","toLowerCase","selectItemWithTextPrefix","setPrefixTimeout","char","resetPrefixTimeout","clearTimeout","setTimeout","TYPING_TIMEOUT_DURATION","constants","SelectionAria","role","itemRole","id","baseId","idCount","itemId","removeAttribute","SelectionInView","scrollItemIntoView","scrollTargetRect","getBoundingClientRect","itemRect","bottomDelta","bottom","topDelta","top","leftDelta","left","rightDelta","right","Math","ceil","scrollLeft","ShadowTemplateMixin","mapTagToTemplate","ShadowTemplate","tag","templateText","createElement","innerHTML","ShadyCSS","prepareTemplate","attachShadow","mode","clone","importNode","appendChild","applyStyle","SingleSelectionMixin","canSelectNextSymbol","canSelectPreviousSymbol","selectionRequiredSymbol","selectionWrapsSymbol","externalSelectedIndexSymbol","externalSelectedItemSymbol","internalSelectedIndexSymbol","internalSelectedItemSymbol","SingleSelection","selectionWraps","trackSelectedItem","updatePossibleNavigations","selectIndex","canSelectNext","canSelectPrevious","parsedIndex","parseInt","hasItems","detail","previousSelectedItem","parsed","boundedIndex","max","min","previousIndex","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","MediaDeviceList","SingleSelectionDemo"],"mappings":"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","file":"demos.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6f0c3521ebd09b09579a","/*\n * This is currently a demo of how multiple mixins cooperate to perform useful\n * functions.\n *\n * * The component uses ShadowTemplateMixin to populate its shadow root.\n * * A user can click on a child item, and ClickSelectionMixin will set the\n *   selected item.\n * * The SingleSelectionMixin will track the selected item, and map that to\n *   changes in the selection state of the selected/deselected items.\n * * The SelectionAriaMixin will reflect an item's selection state using ARIA\n *   attributes to support assistive devices like screen readers.\n *\n * This demo will eventually evolve into a complete list box component, but\n * at the moment omits many features, including support for Page Up/Page Down\n * keys, keeping the selected item in view, the ability to select an item\n * by typing its initial characters, and support for slot elements as children.\n */\n\n\nimport ChildrenContentMixin from '../../elix-mixins/src/ChildrenContentMixin';\nimport ClickSelectionMixin from '../../elix-mixins/src/ClickSelectionMixin';\nimport ContentItemsMixin from '../../elix-mixins/src/ContentItemsMixin';\nimport DirectionSelectionMixin from '../../elix-mixins/src/DirectionSelectionMixin';\nimport KeyboardDirectionMixin from '../../elix-mixins/src/KeyboardDirectionMixin';\nimport KeyboardMixin from '../../elix-mixins/src/KeyboardMixin';\nimport KeyboardPagedSelectionMixin from '../../elix-mixins/src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from '../../elix-mixins/src/KeyboardPrefixSelectionMixin';\nimport SelectionAriaMixin from '../../elix-mixins/src/SelectionAriaMixin';\nimport SelectionInViewMixin from '../../elix-mixins/src/SelectionInViewMixin';\nimport ShadowTemplateMixin from '../../elix-mixins/src/ShadowTemplateMixin';\nimport SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n// We want to apply a number of mixin functions to HTMLElement.\nconst mixins = [\n  ChildrenContentMixin,\n  ClickSelectionMixin,\n  ContentItemsMixin,\n  DirectionSelectionMixin,\n  KeyboardDirectionMixin,\n  KeyboardMixin,\n  KeyboardPagedSelectionMixin,\n  KeyboardPrefixSelectionMixin,\n  SelectionAriaMixin,\n  SelectionInViewMixin,\n  ShadowTemplateMixin,\n  SingleSelectionMixin\n];\n\n// The mixins are functions, so an efficient way to apply them all is with\n// reduce. This is just function composition. We end up with a base class we\n// can extend below.\nconst base = mixins.reduce((cls, mixin) => mixin(cls), HTMLElement);\n\n\n/**\n * A simple single-selection list box.\n *\n * This uses the base class we just created above, and adds in the behavior\n * unique to this list box element. As it turns out, much of this behavior is\n * also interesting to other components, and will eventually get factored into\n * other mixins.\n *\n * @extends HTMLElement\n * @mixes ChildrenContentMixin\n * @mixes ClickSelectionMixin\n * @mixes ContentItemsMixin\n * @mixes DirectionSelectionMixin\n * @mixes KeyboardDirectionMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardPagedSelectionMixin\n * @mixes KeyboardPrefixSelectionMixin\n * @mixes SelectionAriaMixin\n * @mixes SelectionInViewMixin\n * @mixes ShadowTemplateMixin\n * @mixes SingleSelectionMixin\n */\nclass ListBox extends base {\n\n  // Map attribute changes to the corresponding property.\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    const mapAttributeToProperty = {\n      'selected-index': 'selectedIndex'\n    };\n    const propertyName = mapAttributeToProperty[attributeName] || attributeName;\n    this[propertyName] = newValue;\n  }\n\n  // We define a collection of default property values which can be set in\n  // the constructor or connectedCallback. Defining the actual default values\n  // in those calls would complicate things if a subclass someday wants to\n  // define its own default value.\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    // By default, we assume the list presents list items vertically.\n    defaults.orientation = 'vertical';\n    return defaults;\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Tell the browser which attributes we want to handle.\n  static get observedAttributes() {\n    return ['orientation', 'selected-index'];\n  }\n\n  /**\n   * The vertical (default) or horizontal orientation of the list.\n   *\n   * Supported values are \"horizontal\" or \"vertical\".\n   *\n   * @type {string}\n   */\n  get orientation() {\n    return this[symbols.orientation] || this[symbols.defaults].orientation;\n  }\n  set orientation(value) {\n    const changed = value !== this[symbols.orientation];\n    this[symbols.orientation] = value;\n    if ('orientation' in base) { super.orientation = value; }\n    // Reflect attribute for styling\n    if (this.getAttribute('orientation') !== value) {\n      this.setAttribute('orientation', value);\n    }\n    if (changed && this[symbols.raiseChangeEvents]) {\n      const event = new CustomEvent('orientation-changed');\n      this.dispatchEvent(event);\n    }\n  }\n\n  // Define a template that will be stamped into the Shadow DOM by the\n  // ShadowTemplateMixin.\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      #itemsContainer {\n        flex: 1;\n        -webkit-overflow-scrolling: touch; /* for momentum scrolling */\n        overflow-x: hidden;\n        overflow-y: scroll;\n      }\n      :host([orientation=\"horizontal\"]) #itemsContainer {\n        display: flex;\n        overflow-x: scroll;\n        overflow-y: hidden;\n      }\n\n      #itemsContainer ::slotted(*) {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      #itemsContainer ::slotted(.selected) {\n        background: var(--elix-selected-background, highlight);\n        color: var(--elix-selected-color, highlighttext);\n      }\n      </style>\n\n      <div id=\"itemsContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  /**\n   * Fires when the orientation property changes in response to internal\n   * component activity.\n   *\n   * @memberof ListBox\n   * @event orientation-changed\n   */\n}\n\n\ncustomElements.define('sample-list-box', ListBox);\nexport default ListBox;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/ListBox.js","import { assignedChildren } from './content';\nimport microtask from './microtask';\nimport symbols from './symbols';\n\n\n/**\n * Mixin which defines a component's `symbols.content` property as all\n * child elements, including elements distributed to the component's slots.\n *\n * This also provides notification of changes to a component's content. It\n * will invoke a `symbols.contentChanged` method when the component is first\n * instantiated, and whenever its distributed children change. This is intended\n * to satisfy the Gold Standard checklist item for monitoring\n * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n *\n * Example:\n *\n * ```\n * let base = ChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n * class CountingElement extends base {\n *\n *   constructor() {\n *     super();\n *     let root = this.attachShadow({ mode: 'open' });\n *     root.innerHTML = `<slot></slot>`;\n *     this[symbols.shadowCreated]();\n *   }\n *\n *   [symbols.contentChanged]() {\n *     if (super[symbols.contentChanged]) { super[symbols.contentChanged](); }\n *     // Count the component's children, both initially and when changed.\n *     this.count = this.distributedChildren.length;\n *   }\n *\n * }\n * ```\n *\n * Note that content change detection depends upon the element having at least\n * one `slot` element in its shadow subtree.\n *\n * This mixin is intended for use with the\n * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n * a discussion of how that works. This ChildrenContentMixin\n * provides an easy way of defining the \"content\" of a component as the\n * component's distributed children. That in turn lets mixins like\n * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n * items.\n *\n * To receive `contentChanged` notification, this mixin expects a component to\n * invoke a method called `symbols.shadowCreated` after the component's shadow\n * root has been created and populated.\n *\n * Note: This mixin relies upon the browser firing `slotchange` events when the\n * contents of a `slot` change. Safari and the polyfills fire this event when a\n * custom element is first upgraded, while Chrome does not. This mixin always\n * invokes the `contentChanged` method after component instantiation so that the\n * method will always be invoked at least once. However, on Safari (and possibly\n * other browsers), `contentChanged` might be invoked _twice_ for a new\n * component instance.\n *\n * @module ChildrenContentMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ChildrenContentMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => {\n        if (this[symbols.contentChanged]) {\n          this[symbols.contentChanged]();\n        }\n      });\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * The default implementation of this property only returns instances of\n     * Element\n     *\n     * @type {HTMLElement[]}\n     */\n    get [symbols.content]() {\n      return assignedChildren(this);\n    }\n\n    [symbols.shadowCreated]() {\n      if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n      // Listen to changes on all slots.\n      const slots = this.shadowRoot.querySelectorAll('slot');\n      slots.forEach(slot => slot.addEventListener('slotchange', event => {\n        if (this[symbols.contentChanged]) {\n          this[symbols.contentChanged]();\n        }\n      }));\n    }\n  }\n\n  return ChildrenContent;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ChildrenContentMixin.js","/**\n * Helpers for accessing a component's content.\n *\n * The standard DOM API provides several ways of accessing child content:\n * `children`, `childNodes`, and `textContent`. None of these functions are\n * Shadow DOM aware. This mixin defines variations of those functions that\n * *are* Shadow DOM aware.\n *\n * Example: you create a component `<count-children>` that displays a number\n * equal to the number of children placed inside that component. If someone\n * instantiates your component like:\n *\n *     <count-children>\n *       <div></div>\n *       <div></div>\n *       <div></div>\n *     </count-children>\n *\n * Then the component should show \"3\", because there are three children. To\n * calculate the number of children, the component can just calculate\n * `this.children.length`. However, suppose someone instantiates your\n * component inside one of their own components, and puts a `<slot>` element\n * inside your component:\n *\n *     <count-children>\n *       <slot></slot>\n *     </count-children>\n *\n * If your component only looks at `this.children`, it will always see exactly\n * one child — the `<slot>` element. But the user looking at the page will\n * *see* any nodes distributed to that slot. To match what the user sees, your\n * component should expand any `<slot>` elements it contains.\n *\n * That is one problem these helpers solve. For example, the helper\n * `assignedChildren` will return all children assigned to your component in\n * the composed tree.\n *\n * @module content\n */\n\n/**\n * An in-order collection of distributed children, expanding any slot\n * elements. Like the standard `children` property, this skips text and other\n * node types which are not Element instances.\n *\n * @param {HTMLElement} element - the element to inspect\n * @returns {Element[]} - the children assigned to the element\n */\nexport function assignedChildren(element) {\n  return expandAssignedNodes(element.children, true);\n}\n\n/**\n * An in-order collection of distributed child nodes, expanding any slot\n * elements. Like the standard `childNodes` property, this includes text and\n * other types of nodes.\n *\n * @param {HTMLElement} element - the element to inspect\n * @returns {Node[]} - the nodes assigned to the element\n */\nexport function assignedChildNodes(element) {\n  return expandAssignedNodes(element.childNodes, false);\n}\n\n/**\n * The concatenated `textContent` of all distributed child nodes, expanding\n * any slot elements.\n *\n * @param {HTMLElement} element - the element to inspect\n * @type {string} - the text content of all nodes assigned to the element\n */\nexport function assignedTextContent(element) {\n  const strings = assignedChildNodes(element).map(\n    child => child.textContent\n  );\n  return strings.join('');\n}\n\n/**\n * Return the given elements, filtering out auxiliary elements that aren't\n * typically visible. Given a `NodeList` or array of objects, it will only\n * return array members that are instances of `Element` (`HTMLElement` or\n * `SVGElement`), and not on a blacklist of normally invisible elements\n * (such as `style` or `script`).\n *\n * @param {NodeList|Element[]} elements - the list of elements to filter\n * @returns {Element[]} - the filtered elements\n */\nexport function filterAuxiliaryElements(elements) {\n\n  // These are tags that can appear in the document body, but do not seem to\n  // have any user-visible manifestation.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n  const auxiliaryTags = [\n    'applet',         // deprecated\n    'basefont',       // deprecated\n    'embed',\n    'font',           // deprecated\n    'frame',          // deprecated\n    'frameset',       // deprecated\n    'isindex',        // deprecated\n    'keygen',         // deprecated\n    'link',\n    'multicol',       // deprecated\n    'nextid',         // deprecated\n    'noscript',\n    'object',\n    'param',\n    'script',\n    'style',\n    'template',\n    'noembed'         // deprecated\n  ];\n\n  return [].filter.call(elements,\n    element => element instanceof Element &&\n        (!element.localName || auxiliaryTags.indexOf(element.localName) < 0)\n  );\n}\n\n//\n// Helpers for the helper functions\n//\n\n/*\n * Given a array of nodes, return a new array with any `slot` elements expanded\n * to the nodes assigned to those slots.\n *\n * If ElementsOnly is true, only Element instances are returned, as with the\n * standard `children` property. Otherwise, all nodes are returned, as in the\n * standard `childNodes` property.\n */\nfunction expandAssignedNodes(nodes, ElementsOnly) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n\n    return isSlot ?\n      node.assignedNodes({ flatten: true }) :\n      [node];\n  });\n  const flattened = [].concat(...expanded);\n  const result = ElementsOnly ?\n    flattened.filter(node => node instanceof Element) :\n    flattened;\n  return result;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/content.js","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/microtask.js","import Symbol from './Symbol';\n\n\n/**\n * A collection of (potentially polyfilled) Symbol objects for standard\n * component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbols for the `content` property.\n   *\n   * This property returns the component's content -- however the component\n   * wants to define that. This could, for example, return the component's\n   * distributed children.\n   *\n   * @type {HTMLElement[]}\n   */\n  content: Symbol('content'),\n\n  /**\n   * Symbol for the `contentChanged` method.\n   *\n   * For components that define a `content` property, this method should be\n   * invoked when that property changes.\n   *\n   * @function contentChanged\n   */\n  contentChanged: Symbol('contentChanged'),\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: Symbol('defaults'),\n\n  /**\n   * Symbol for the `getItemText` method.\n   *\n   * This method can be applied to an item to return its text.\n   *\n   * @function getText\n   * @param {HTMLElement} item - the item to extract text from\n   * @returns {string} - the text of the item\n   */\n  getItemText: Symbol('getText'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: Symbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: Symbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: Symbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: Symbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: Symbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: Symbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: Symbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   *\n   * @function itemsChanged\n   */\n  itemsChanged: Symbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: Symbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: Symbol('keydown'),\n\n  /**\n   * Indicates the general horizontal and/or vertical orientation of the\n   * component. This may affect both presentation and behavior (e.g., of\n   * keyboard navigation).\n   *\n   * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n   *\n   * @type {string}\n   */\n  orientation: Symbol('orientation'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. For a detailed discussion\n   * of this point, see the Gold Standard checklist item for\n   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n   *\n   * The above article describes a pattern for using a flag to track whether\n   * work is being performed in response to internal component activity, and\n   * whether the component should therefore raise property change events.\n   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n   * all Elix mixins and components. Sharing this flag ensures that internal\n   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n   * handling affected properties to raise change events.\n   *\n   * All UI event listeners (and other forms of internal handlers, such as\n   * timeouts and async network handlers) should set `raiseChangeEvents` to\n   * `true` at the start of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   * @var {boolean} raiseChangeEvents\n   */\n  raiseChangeEvents: Symbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `shadowCreated` method.\n   *\n   * This method is invoked when the component's shadow root has been attached\n   * and populated. Other code can handle this method to perform initialization\n   * that depends upon the existence of a populated shadow subtree.\n   *\n   * @function shadowCreated\n   */\n  shadowCreated: Symbol('shadowCreated'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLTemplateElement}\n   */\n  template: Symbol('template')\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/symbols.js","/* The number of fake symbols we've served up */\nlet count = 0;\n\nfunction uniqueString(description) {\n  return `_${description}${count++}`;\n}\n\nconst symbolFunction = typeof window.Symbol === 'function' ?\n  window.Symbol :\n  uniqueString;\n\n/**\n * Polyfill for ES6 symbol class.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. In\n * lieu of returning a true Symbol, this polyfill returns a different string\n * each time it is called.\n *\n * Usage:\n *\n *     const fooSymbol = Symbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property that looks\n * like this._foo0. The underscore is meant to reduce (not eliminate) potential\n * accidental access, and the unique number at the end is mean to avoid (not\n * eliminate) naming conflicts.\n *\n * @function Symbol\n * @param {string} description - A string to identify the symbol when debugging\n * @returns {Symbol|string} — A Symbol (in ES6 browsers) or unique string ID (in\n * ES5).\n */\nexport default symbolFunction;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/Symbol.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps a click (actually, a mousedown) to a selection.\n *\n * This simple mixin is useful in list box-like elements, where a click on a\n * list item implicitly selects it.\n *\n * The standard use for this mixin is in list-like elements. Native list\n * boxes don't appear to be consistent with regard to whether they select\n * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n * On touch devices, that event appears to trigger when the touch is *released*.\n *\n * This mixin only listens to mousedown events for the primary mouse button\n * (typically the left button). Right-clicks are ignored so that the browser\n * may display a context menu.\n *\n * Much has been written about how to ensure \"fast tap\" behavior on mobile\n * devices. This mixin makes a very straightforward use of a standard event, and\n * this appears to perform well on mobile devices when, e.g., the viewport is\n * configured with `width=device-width`.\n *\n * This mixin expects the component to provide an `items` property. It also\n * expects the component to define a `selectedItem` property; you can provide\n * that yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * If the component receives a clicks that doesn't correspond to an item (e.g.,\n * the user clicks on the element background visible between items), the\n * selection will be removed. However, if the component defines a\n * `selectionRequired` and this is true, a background click will *not* remove\n * the selection.\n *\n * @module ClickSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ClickSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('mousedown', event => {\n\n        // Only process events for the main (usually left) button.\n        if (event.button !== 0) {\n          return;\n        }\n\n        this[symbols.raiseChangeEvents] = true;\n\n        // If the item clicked on is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET) — but the event target will be the component, not\n        // the item that was clicked on.\n        const target = event.target === this ?\n          event.path[0] : // Event target isn't the item, so get it from path.\n          event.target;\n\n        // Find which item was clicked on and, if found, select it. For elements\n        // which don't require a selection, a background click will determine\n        // the item was null, in which we case we'll remove the selection.\n        const item = itemForTarget(this, target);\n        if (item || !this.selectionRequired) {\n\n          if (!('selectedItem' in this)) {\n            console.warn(`ClickSelectionMixin expects a component to define a \"selectedItem\" property.`);\n          } else {\n            this.selectedItem = item;\n          }\n\n          // We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n  }\n\n  return ClickSelection;\n}\n\n\n/*\n * Return the list item that is, or contains, the indicated target element.\n * Return null if not found.\n */\nfunction itemForTarget(listElement, target) {\n  const items = listElement.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ClickSelectionMixin.js","import * as content from './content';\nimport Symbol from './Symbol';\nimport symbols from './symbols';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = Symbol('items');\nconst itemInitializedSymbol = Symbol('itemInitialized');\n\n\n/**\n * Mixin which maps content semantics (elements) to list item semantics.\n *\n * Items differ from element contents in several ways:\n *\n * * They are often referenced via index.\n * * They may have a selection state.\n * * It's common to do work to initialize the appearance or state of a new\n *   item.\n * * Auxiliary invisible child elements are filtered out and not counted as\n *   items. Auxiliary elements include link, script, style, and template\n *   elements. This filtering ensures that those auxiliary elements can be\n *   used in markup inside of a list without being treated as list items.\n *\n * This mixin expects a component to provide a `content` property returning a\n * raw set of elements. You can provide that yourself, or use\n * [ChildrenContentMixin](ChildrenContentMixin.md).\n *\n * [ChildrenContentMixin](ChildrenContentMixin.md), the\n * `contentChanged` method will be invoked for you when the element's children\n * care of notifying it of future changes, and turns on the optimization. With\n * change, turning on the optimization automatically.\n * method when the set of items changes, the mixin concludes that you'll take\n * property. To avoid having to do work each time that property is requested,\n * return that immediately on subsequent calls to the `items` property. If you\n * that on, the mixin saves a reference to the computed set of items, and will\n * The most commonly referenced property defined by this mixin is the `items`\n * this mixin supports an optimized mode. If you invoke the `contentChanged`\n * use this mixin in conjunction with\n *\n * @module ContentItemsMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ContentItemsMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ContentItems extends base {\n\n    [symbols.contentChanged]() {\n      if (super[symbols.contentChanged]) { super[symbols.contentChanged](); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = content.filterAuxiliaryElements(this[symbols.content]);\n        // Note: test for *equality* with null, since we use `undefined` to\n        // indicate that we're not yet caching items.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization – since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization if `itemAdded` is defined.\n      if (this[symbols.itemAdded]) {\n        Array.prototype.forEach.call(this.items, item => {\n          if (!item[itemInitializedSymbol]) {\n            this[symbols.itemAdded](item);\n            item[itemInitializedSymbol] = true;\n          }\n        });\n      }\n\n      if (this[symbols.raiseChangeEvents]) {\n        this.dispatchEvent(new CustomEvent('items-changed'));\n      }\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ContentItemsMixin.js","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/toggleClass.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n * semantics (selectPrevious, selectNext, etc.).\n *\n * This mixin can be used in conjunction with\n * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n * events to directions) and a mixin that handles selection like\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module DirectionSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function DirectionSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      if (!this.selectNext) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectNext\" method.`);\n      } else {\n        return this.selectNext();\n      }\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      if (!this.selectLast) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectLast\" method.`);\n      } else {\n        return this.selectLast();\n      }\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      if (!this.selectPrevious) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.`);\n      } else {\n        return this.selectPrevious();\n      }\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      if (!this.selectNext) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectNext\" method.`);\n      } else {\n        return this.selectNext();\n      }\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      if (!this.selectFirst) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectFirst\" method.`);\n      } else {\n        return this.selectFirst();\n      }\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      if (!this.selectPrevious) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.`);\n      } else {\n        return this.selectPrevious();\n      }\n    }\n\n  }\n\n  return DirectionSelection;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/DirectionSelectionMixin.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n * (go left, go right, etc.).\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin calls methods such as `goLeft` and `goRight`. You can define\n * what that means by implementing those methods yourself. If you want to use\n * direction keys to navigate a selection, use this mixin with\n * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n *\n * If the component defines a property called `symbols.orientation`, the value\n * of that property will constrain navigation to the horizontal or vertical axis.\n *\n * @module KeyboardDirectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardDirectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class KeyboardDirection extends base {\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    [symbols.keydown](event) {\n      let handled = false;\n\n      const orientation = this[symbols.orientation] || 'both';\n      const horizontal = (orientation === 'horizontal' || orientation === 'both');\n      const vertical = (orientation === 'vertical' || orientation === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event)) || false;\n    }\n\n  }\n\n  return KeyboardDirection;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardDirectionMixin.js","import symbols from './symbols';\n\n\n/**\n * Mixin which manages the keydown handling for a component.\n *\n * This mixin handles several keyboard-related features.\n *\n * First, it wires up a single keydown event handler that can be shared by\n * multiple mixins on a component. The event handler will invoke a `keydown`\n * method with the event object, and any mixin along the prototype chain that\n * wants to handle that method can do so.\n *\n * If a mixin wants to indicate that keyboard event has been handled, and that\n * other mixins should *not* handle it, the mixin's `keydown` handler should\n * return a value of true. The convention that seems to work well is that a\n * mixin should see if it wants to handle the event and, if not, then ask the\n * superclass to see if it wants to handle the event. This has the effect of\n * giving the mixin that was applied last the first chance at handling a\n * keyboard event.\n *\n * Example:\n *\n *     [symbols.keydown](event) {\n *       let handled;\n *       switch (event.keyCode) {\n *         // Handle the keys you want, setting handled = true if appropriate.\n *       }\n *       // Prefer mixin result if it's defined, otherwise use base result.\n *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n *     }\n *\n * Until iOS Safari supports the `KeyboardEvent.key` property\n * (see http://caniuse.com/#search=keyboardevent.key), mixins should generally\n * test keys using the legacy `keyCode` property, not `key`.\n *\n * A second feature provided by this mixin is that it implicitly makes the\n * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n * has the effect of adding the component to the tab order in document order.\n *\n * @module KeyboardMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        this[symbols.raiseChangeEvents] = true;\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardMixin.js","import defaultScrollTarget from './defaultScrollTarget';\nimport symbols from './symbols';\n\n\n/**\n * Mixin which maps page keys (Page Up, Page Down) into operations that move\n * the selection by one page.\n *\n * The keyboard interaction model generally follows that of Microsoft Windows'\n * list boxes instead of those in OS X:\n *\n * * The Page Up/Down and Home/End keys actually change the selection, rather\n *   than just scrolling. The former behavior seems more generally useful for\n *   keyboard users.\n *\n * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n *   visible item if the selection is not already there. Thereafter, the key\n *   will move the selection up/down by a page, and (per the above point) make\n *   the selected item visible.\n *\n * To ensure the selected item is in view following use of Page Up/Down, use\n * the related [SelectionInViewMixin](SelectionInViewMixin.md).\n *\n * This mixin expects the component to provide:\n *\n * * A `[symbols.keydown]` method invoked when a key is pressed. You can use\n *   [KeyboardMixin](KeyboardMixin.md) for that purpose, or wire up your own\n *   keyboard handling and call `[symbols.keydown]` yourself.\n * * A `selectedIndex` property that indicates the index of the selected item.\n *\n * @module KeyboardPagedSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardPagedSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class KeyboardPagedSelection extends base {\n\n    [symbols.keydown](event) {\n      let handled = false;\n      const orientation = this[symbols.orientation];\n      if (orientation !== 'horizontal') {\n        switch (event.keyCode) {\n          case 33: // Page Up\n          handled = this.pageUp();\n          break;\n          case 34: // Page Down\n          handled = this.pageDown();\n          break;\n        }\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) { super.pageDown(); }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) { super.pageUp(); }\n      return scrollOnePage(this, false);\n    }\n\n    /* Provide a default scrollTarget implementation if none exists. */\n    get [symbols.scrollTarget]() {\n      return super[symbols.scrollTarget] || defaultScrollTarget(this);\n    }\n\n  }\n\n  return KeyboardPagedSelection;\n}\n\n\n// Return the item whose content spans the given y position (relative to the\n// top of the list's scrolling client area), or null if not found.\n//\n// If downward is true, move down the list of items to find the first item\n// found at the given y position; if downward is false, move up the list of\n// items to find the last item at that position.\nfunction getIndexOfItemAtY(element, scrollTarget, y, downward) {\n\n  const items = element.items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n\n  const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\n  // Find the item spanning the indicated y coordinate.\n  let item;\n  let itemIndex = start;\n  let itemTop;\n  let found = false;\n  while (itemIndex !== end) {\n    item = items[itemIndex];\n    itemTop = item.offsetTop - topOfClientArea;\n    const itemBottom = itemTop + item.offsetHeight;\n    if (itemTop <= y && itemBottom >= y) {\n      // Item spans the indicated y coordinate.\n      found = true;\n      break;\n    }\n    itemIndex += step;\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = parseFloat(itemStyle.paddingTop);\n  const itemPaddingBottom = parseFloat(itemStyle.paddingBottom);\n  const contentTop = itemTop + item.clientTop + itemPaddingTop;\n  const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n    // The indicated coordinate hits the actual item content.\n    return itemIndex;\n  }\n  else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return itemIndex - step;\n  }\n}\n\n// Move by one page downward (if downward is true), or upward (if false).\n// Return true if we ended up changing the selection, false if not.\nfunction scrollOnePage(element, downward) {\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll select that item if it's not already selected.\n  const scrollTarget = element[symbols.scrollTarget];\n  const edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, scrollTarget, edge, downward);\n\n  const selectedIndex = element.selectedIndex;\n  let newIndex;\n  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n    // The item at the edge was already selected, so scroll in the indicated\n    // direction by one page. Leave the new item at that edge selected.\n    const delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n    newIndex = getIndexOfItemAtY(element, scrollTarget, edge + delta, downward);\n  }\n  else {\n    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n    // just select that item. That is, the first attempt to page up/down\n    // usually just moves the selection to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We can't find an item in the direction we want to travel. Select the\n    // last item (if moving downward) or first item (if moving upward).\n    newIndex = (downward ? element.items.length - 1 : 0);\n  }\n\n  if (newIndex !== selectedIndex) {\n    element.selectedIndex = newIndex;\n    return true; // We handled the page up/down ourselves.\n  }\n  else {\n    return false; // We didn't do anything.\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardPagedSelectionMixin.js","/**\n * Return a guess as to what portion of the given element can be scrolled.\n * This can be used to provide a default implementation of\n * [symbols.scrollTarget].\n *\n * If the element has a shadow root containing a default (unnamed) slot, this\n * returns the first ancestor of that slot that is styled with `overflow-y:\n * auto` or `overflow-y: scroll`. If the element has no default slot, or no\n * scrolling ancestor is found, the element itself is returned.\n *\n * @type {HTMLElement}\n */\nexport default function defaultScrollTarget(element) {\n  const slot = element.shadowRoot && element.shadowRoot.querySelector('slot:not([name])');\n  return slot ?\n    getScrollingParent(slot, element) :\n    element;\n}\n\n\n// Return the parent of the given element that can be scroll vertically. If no\n// such element is found, return the given root element.\nfunction getScrollingParent(element, root) {\n  if (element === null || element === root) {\n    // Didn't find a scrolling parent; use the root element instead.\n    return root;\n  }\n  const overflowY = getComputedStyle(element).overflowY;\n  if (overflowY === 'scroll' || overflowY === 'auto') {\n    // Found an element we can scroll vertically.\n    return element;\n  }\n  // Keep looking higher in the hierarchy for a scrolling parent.\n  return getScrollingParent(element.parentNode, root);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/defaultScrollTarget.js","import constants from './constants';\nimport Symbol from './Symbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemTextContentsSymbol = Symbol('itemTextContents');\nconst typedPrefixSymbol = Symbol('typedPrefix');\nconst prefixTimeoutSymbol = Symbol('prefixTimeout');\nconst settingSelectionSymbol = Symbol('settingSelection');\n\n\n/**\n * Mixin that handles list box-style prefix typing, in which the user can type\n * a string to select the first item that begins with that string.\n *\n * Example: suppose a component using this mixin has the following items:\n *\n *     <sample-list-component>\n *       <div>Apple</div>\n *       <div>Apricot</div>\n *       <div>Banana</div>\n *       <div>Blackberry</div>\n *       <div>Blueberry</div>\n *       <div>Cantaloupe</div>\n *       <div>Cherry</div>\n *       <div>Lemon</div>\n *       <div>Lime</div>\n *     </sample-list-component>\n *\n * If this component receives the focus, and the user presses the \"b\" or \"B\"\n * key, the \"Banana\" item will be selected, because it's the first item that\n * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n * \"Blackberry\" will be selected.\n *\n * The prefix typing feature has a one second timeout — the prefix to match\n * will be reset after a second has passed since the user last typed a key.\n * If, in the above example, the user waits a second between typing \"b\" and\n * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin also expects the component to provide an `items` property. The\n * `textContent` of those items will be used for purposes of prefix matching.\n *\n * @module KeyboardPrefixSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardPrefixSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class KeyboardPrefixSelection extends base {\n\n    // Default implementation returns an item's `alt` attribute or its\n    // `textContent`, in that order.\n    [symbols.getItemText](item) {\n      return item.getAttribute('alt') || item.textContent;\n    }\n\n    // If the set of items has changed, reset the prefix. We'll also need to\n    // rebuild our cache of item text the next time we're asked for it.\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n      this[itemTextContentsSymbol] = null;\n      resetTypedPrefix(this);\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n      let resetPrefix = true;\n\n      switch (event.keyCode) {\n        case 8: // Backspace\n          handleBackspace(this);\n          handled = true;\n          resetPrefix = false;\n          break;\n        case 27: // Escape\n          handled = true;\n          break;\n        default:\n          if (!event.ctrlKey && !event.metaKey && !event.altKey &&\n              event.which !== 32 /* Space */) {\n            handlePlainCharacter(this, String.fromCharCode(event.keyCode));\n          }\n          resetPrefix = false;\n      }\n\n      if (resetPrefix) {\n        resetTypedPrefix(this);\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      if (!this[settingSelectionSymbol]) {\n        // Someone else (not this mixin) has changed the selection. In response,\n        // we invalidate the prefix under construction.\n        resetTypedPrefix(this);\n      }\n    }\n\n    /**\n     * Select the first item whose text content begins with the given prefix.\n     *\n     * @param prefix [String] The prefix string to search for\n     */\n    selectItemWithTextPrefix(prefix) {\n      if (super.selectItemWithTextPrefix) { super.selectItemWithTextPrefix(prefix); }\n      if (prefix == null || prefix.length === 0) {\n        return;\n      }\n      const index = getIndexOfItemWithTextPrefix(this, prefix);\n      if (index >= 0) {\n        // Update the selection. During that operation, set the flag that lets\n        // us know that we are the cause of the selection change. See note at\n        // this mixin's `selectedIndex` implementation.\n        this[settingSelectionSymbol] = true;\n        this.selectedIndex = index;\n        this[settingSelectionSymbol] = false;\n      }\n    }\n\n  }\n\n  return KeyboardPrefixSelection;\n}\n\n\n// Return the index of the first item with the given prefix, else -1.\nfunction getIndexOfItemWithTextPrefix(element, prefix) {\n  const itemTextContents = getItemTextContents(element);\n  const prefixLength = prefix.length;\n  for (let i = 0; i < itemTextContents.length; i++) {\n    const itemTextContent = itemTextContents[i];\n    if (itemTextContent.substr(0, prefixLength) === prefix) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Return an array of the text content (in lowercase) of all items.\n// Cache these results.\nfunction getItemTextContents(element) {\n  if (!element[itemTextContentsSymbol]) {\n    const items = element.items;\n    element[itemTextContentsSymbol] = Array.prototype.map.call(items, item => {\n      const text = element[symbols.getItemText](item);\n      return text.toLowerCase();\n    });\n  }\n  return element[itemTextContentsSymbol];\n}\n\n// Handle the Backspace key: remove the last character from the prefix.\nfunction handleBackspace(element) {\n  const length = element[typedPrefixSymbol] ? element[typedPrefixSymbol].length : 0;\n  if (length > 0) {\n    element[typedPrefixSymbol] = element[typedPrefixSymbol].substr(0, length - 1);\n  }\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\n// Add a plain character to the prefix.\nfunction handlePlainCharacter(element, char) {\n  const prefix = element[typedPrefixSymbol] || '';\n  element[typedPrefixSymbol] = prefix + char.toLowerCase();\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\n// Stop listening for typing.\nfunction resetPrefixTimeout(element) {\n  if (element[prefixTimeoutSymbol]) {\n    clearTimeout(element[prefixTimeoutSymbol]);\n    element[prefixTimeoutSymbol] = false;\n  }\n}\n\n// Clear the prefix under construction.\nfunction resetTypedPrefix(element) {\n  element[typedPrefixSymbol] = '';\n  resetPrefixTimeout(element);\n}\n\n// Wait for the user to stop typing.\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  element[prefixTimeoutSymbol] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, constants.TYPING_TIMEOUT_DURATION);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardPrefixSelectionMixin.js","/**\n * A collection of constants used by Elix mixins and components for consistency\n * in things such as user interface timings.\n *\n * @module constants\n */\nconst constants = {\n\n  /**\n   * Time in milliseconds after which the user is considered to have stopped\n   * typing.\n   *\n   * @const {number} TYPING_TIMEOUT_DURATION\n   */\n  TYPING_TIMEOUT_DURATION: 1000\n\n};\n\n\nexport default constants;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/constants.js","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/**\n * Mixin which treats the selected item in a list as the active item in ARIA\n * accessibility terms.\n *\n * Handling ARIA selection state properly is actually quite complex:\n *\n * * The items in the list need to be indicated as possible items via an ARIA\n *   `role` attribute value such as \"option\".\n * * The selected item need to be marked as selected by setting the item's\n *   `aria-selected` attribute to true *and* the other items need be marked as\n *   *not* selected by setting `aria-selected` to false.\n * * The outermost element with the keyboard focus needs to have attributes\n *   set on it so that the selection is knowable at the list level via the\n *   `aria-activedescendant` attribute.\n * * Use of `aria-activedescendant` in turn requires that all items in the\n *   list have ID attributes assigned to them.\n *\n * This mixin tries to address all of the above requirements. To that end,\n * this mixin will assign generated IDs to any item that doesn't already have\n * an ID.\n *\n * ARIA relies on elements to provide `role` attributes. This mixin will apply\n * a default role of \"listbox\" on the outer list if it doesn't already have an\n * explicit role. Similarly, this mixin will apply a default role of \"option\"\n * to any list item that does not already have a role specified.\n *\n * This mixin expects a set of members that manage the state of the selection:\n * `[symbols.itemSelected]`, `[symbols.itemAdded]`, and `selectedItem`. You can\n * supply these yourself, or do so via\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function (base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SelectionAria extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the overall component.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      defaults.itemRole = 'option';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role for an individual item.\n        item.setAttribute('role', this[symbols.defaults].itemRole);\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAria;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SelectionAriaMixin.js","import defaultScrollTarget from './defaultScrollTarget';\nimport symbols from './symbols';\n\n\n/**\n * Mixin which scrolls a container horizontally and/or vertically to ensure that\n * a newly-selected item is visible to the user.\n *\n * When the selected item in a list-like component changes, the selected item\n * should be brought into view so that the user can confirm their selection.\n *\n * This mixin expects a `selectedItem` property to be set when the selection\n * changes. You can supply that yourself, or use\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module SelectinInViewMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default (base) => {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SelectionInView extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      const selectedItem = this.selectedItem;\n      if (selectedItem) {\n        this.scrollItemIntoView(selectedItem);\n      }\n    }\n\n    /**\n     * Scroll the given element completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * This scrolls the containing element defined by the `scrollTarget`\n     * property. See that property for a discussion of the default value of\n     * that property.\n     *\n     * @param {HTMLElement} item - the item to scroll into view.\n     */\n    scrollItemIntoView(item) {\n      if (super.scrollItemIntoView) { super.scrollItemIntoView(); }\n\n      const scrollTarget = this[symbols.scrollTarget];\n\n      // Determine the bounds of the scroll target and item. We use\n      // getBoundingClientRect instead of .offsetTop, etc., because the latter\n      // round values, and we want to handle fractional values.\n      const scrollTargetRect = scrollTarget.getBoundingClientRect();\n      const itemRect = item.getBoundingClientRect();\n\n      // Determine how far the item is outside the viewport.\n      const bottomDelta = itemRect.bottom - scrollTargetRect.bottom;\n      const topDelta = itemRect.top - scrollTargetRect.top;\n      const leftDelta = itemRect.left - scrollTargetRect.left;\n      const rightDelta = itemRect.right - scrollTargetRect.right;\n\n      // Scroll the target as necessary to bring the item into view.\n      if (bottomDelta > 0) {\n        scrollTarget.scrollTop += bottomDelta;            // Scroll down\n      } else if (topDelta < 0) {\n        scrollTarget.scrollTop += Math.ceil(topDelta);    // Scroll up\n      }\n      if (rightDelta > 0) {\n        scrollTarget.scrollLeft += rightDelta;            // Scroll right\n      } else if (leftDelta < 0) {\n        scrollTarget.scrollLeft += Math.ceil(leftDelta);  // Scroll left\n      }\n    }\n\n    /* Provide a default scrollTarget implementation if none exists. */\n    get [symbols.scrollTarget]() {\n      return super[symbols.scrollTarget] || defaultScrollTarget(this);\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item) {\n        // Keep the selected item in view.\n        this.scrollItemIntoView(item);\n      }\n    }\n  }\n\n  return SelectionInView;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SelectionInViewMixin.js","import symbols from '../src/symbols';\n\n\n// A cache of processed templates.\n//\n// We maintain this as a map keyed by element tag (localName). We could store\n// an element's processed template on its element prototype. One scenario that\n// wouldn't support would be registration of the same constructor under multiple\n// tag names, which was a (perhaps theoretical) use case for Custom Elements.\n//\nconst mapTagToTemplate = {};\n\n\n/**\n * Mixin which adds stamping a template into a Shadow DOM subtree upon component\n * instantiation.\n *\n * To use this mixin, define a `template` property as a string or HTML\n * `<template>` element:\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       get [symbols.template]() {\n *         return `Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` property, this\n * mixin has no effect.\n *\n * For the time being, this extension retains support for Shadow DOM v0. That\n * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n * implement Shadow DOM v1.\n *\n * @module ShadowTemplateMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ShadowTemplateMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n\n      const tag = this.localName;\n      let template = mapTagToTemplate[tag];\n\n      // See if we've already processed a template for this tag.\n      if (!template) {\n        // This is the first time we've created an instance of this tag.\n\n        // Get the template and perform initial processing.\n        template = this[symbols.template];\n        if (!template) {\n          console.warn(`ShadowTemplateMixin expects a component to define a property called [symbols.template].`);\n          return;\n        }\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          const templateText = template;\n          template = document.createElement('template');\n          template.innerHTML = templateText;\n        }\n\n        if (window.ShadyCSS) {\n          // Let the CSS polyfill do its own initialization.\n          window.ShadyCSS.prepareTemplate(template, tag);\n        }\n\n        // Store this for the next time we create the same type of element.\n        mapTagToTemplate[tag] = template;\n      }\n\n      // Stamp the template into a new shadow root.\n      const root = this.attachShadow({ mode: 'open' });\n      const clone = document.importNode(template.content, true);\n      root.appendChild(clone);\n\n      /* Let the component know the shadow tree has been populated. */\n      if (this[symbols.shadowCreated]) {\n        this[symbols.shadowCreated]();\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.applyStyle(this);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ShadowTemplateMixin.js","import Symbol from './Symbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = Symbol('canSelectNext');\nconst canSelectPreviousSymbol = Symbol('canSelectPrevious');\nconst selectionRequiredSymbol = Symbol('selectionRequired');\nconst selectionWrapsSymbol = Symbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = Symbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = Symbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = Symbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = Symbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      const parsed = String(selectionRequired) === 'true';\n      const changed = parsed !== this[selectionRequiredSymbol];\n      this[selectionRequiredSymbol] = parsed;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-required-changed');\n          this.dispatchEvent(event);\n        }\n        if (selectionRequired) {\n          trackSelectedItem(this);\n        }\n      }\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(selectionWraps) {\n      const parsed = String(selectionWraps) === 'true';\n      const changed = parsed !== this[selectionWrapsSymbol];\n      this[selectionWrapsSymbol] = parsed;\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = selectionWraps; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-wraps-changed');\n          this.dispatchEvent(event);\n        }\n        updatePossibleNavigations(this);\n      }\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SingleSelectionMixin.js","/*\n * Demo of a list box with hard-coded contents.\n */\n\n\nimport ClickSelectionMixin from '../../elix-mixins/src/ClickSelectionMixin';\nimport ContentItemsMixin from '../../elix-mixins/src/ContentItemsMixin';\nimport DirectionSelectionMixin from '../../elix-mixins/src/DirectionSelectionMixin';\nimport KeyboardDirectionMixin from '../../elix-mixins/src/KeyboardDirectionMixin';\nimport KeyboardMixin from '../../elix-mixins/src/KeyboardMixin';\nimport KeyboardPagedSelectionMixin from '../../elix-mixins/src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from '../../elix-mixins/src/KeyboardPrefixSelectionMixin';\nimport SelectionAriaMixin from '../../elix-mixins/src/SelectionAriaMixin';\nimport SelectionInViewMixin from '../../elix-mixins/src/SelectionInViewMixin';\nimport ShadowTemplateMixin from '../../elix-mixins/src/ShadowTemplateMixin';\nimport SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n// We want to apply a number of mixin functions to HTMLElement.\nconst mixins = [\n  ClickSelectionMixin,\n  ContentItemsMixin,\n  DirectionSelectionMixin,\n  KeyboardDirectionMixin,\n  KeyboardMixin,\n  KeyboardPagedSelectionMixin,\n  KeyboardPrefixSelectionMixin,\n  SelectionAriaMixin,\n  SelectionInViewMixin,\n  ShadowTemplateMixin,\n  SingleSelectionMixin\n];\n\n// The mixins are functions, so an efficient way to apply them all is with\n// reduce. This is just function composition. We end up with a base class we\n// can extend below.\nconst base = mixins.reduce((cls, mixin) => mixin(cls), HTMLElement);\n\n\nclass MediaDeviceList extends base {\n\n  // Map attribute changes to the corresponding property.\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    const mapAttributeToProperty = {\n      'selected-index': 'selectedIndex'\n    };\n    const propertyName = mapAttributeToProperty[attributeName] || attributeName;\n    this[propertyName] = newValue;\n  }\n\n  get [symbols.content]() {\n    return this.shadowRoot.querySelector('#devicesContainer').children;\n  }\n\n  // We define a collection of default property values which can be set in\n  // the constructor or connectedCallback. Defining the actual default values\n  // in those calls would complicate things if a subclass someday wants to\n  // define its own default value.\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    // By default, we assume the list presents list items vertically.\n    defaults.orientation = 'vertical';\n    return defaults;\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Tell the browser which attributes we want to handle.\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n  [symbols.shadowCreated]() {\n    if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n    this[symbols.contentChanged]();\n  }\n\n  // Define a template that will be stamped into the Shadow DOM by the\n  // ShadowTemplateMixin.\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      #devicesContainer {\n        flex: 1;\n        -webkit-overflow-scrolling: touch; /* for momentum scrolling */\n        overflow-x: hidden;\n        overflow-y: scroll;\n      }\n\n      #devicesContainer > * {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      #devicesContainer > .selected {\n        background: highlight;\n        color: highlighttext;\n      }\n      </style>\n\n      <div id=\"devicesContainer\" role=\"none\">\n        <div>Device 1</div>\n        <div>Device 2</div>\n        <div>Device 3</div>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('media-device-list', MediaDeviceList);\nexport default MediaDeviceList;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/MediaDeviceList.js","import SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n/*\n * A very simple component to show the application of SingleSelectionMixin.\n *\n * For a more complete demo using SingleSelectionMixin, see the ListBox demo.\n */\nexport default class SingleSelectionDemo extends SingleSelectionMixin(HTMLElement) {\n\n  constructor() {\n    super();\n    this.addEventListener('mousedown', event => {\n      this[symbols.raiseChangeEvents] = true;\n      this.selectedItem = event.target;\n      event.stopPropagation();\n      this[symbols.raiseChangeEvents] = false;\n    });\n  }\n\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = newValue;\n    }\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of items property — doesn't handle redistribution.\n  get items() {\n    return this.children;\n  }\n\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n}\n\n\ncustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/SingleSelectionDemo.js"],"sourceRoot":""}