{"version":3,"sources":["webpack:///webpack/bootstrap f0fe6c906c5cec7dfca3","webpack:///./elements/demos/src/ListBox.js","webpack:///./elements/elix-mixins/src/ClickSelectionMixin.js","webpack:///./elements/elix-mixins/src/symbols.js","webpack:///./elements/elix-mixins/src/Symbol.js","webpack:///./elements/elix-mixins/src/SelectionAriaMixin.js","webpack:///./elements/elix-mixins/src/ShadowTemplateMixin.js","webpack:///./elements/elix-mixins/src/SingleSelectionMixin.js","webpack:///./elements/demos/src/SingleSelectionDemo.js"],"names":["mixins","base","reduce","cls","mixin","HTMLElement","ListBox","addEventListener","raiseChangeEvents","handled","event","keyCode","selectPrevious","selectNext","preventDefault","stopPropagation","setTimeout","itemsChanged","attributeName","oldValue","newValue","selectedIndex","parseInt","getAttribute","defaults","tabindex","setAttribute","itemSelected","item","selected","classList","toggle","Array","prototype","forEach","call","items","itemAdded","child","children","template","customElements","define","ClickSelectionMixin","ClickSelection","target","composedPath","itemForTarget","selectionRequired","console","warn","selectedItem","listElement","itemCount","length","i","contains","symbols","count","uniqueString","description","symbolFunction","window","Symbol","SelectionAria","role","itemRole","id","baseId","idCount","itemId","removeAttribute","ShadowTemplateMixin","mapTagToTemplate","ShadowTemplate","tag","localName","templateText","document","createElement","innerHTML","ShadyCSS","prepareTemplate","root","attachShadow","mode","clone","importNode","content","appendChild","applyStyle","SingleSelectionMixin","canSelectNextSymbol","canSelectPreviousSymbol","selectionRequiredSymbol","selectionWrapsSymbol","externalSelectedIndexSymbol","externalSelectedItemSymbol","internalSelectedIndexSymbol","internalSelectedItemSymbol","SingleSelection","selectionWraps","trackSelectedItem","updatePossibleNavigations","selectIndex","newIndex","canSelectNext","changed","dispatchEvent","CustomEvent","canSelectPrevious","index","parsedIndex","hasItems","detail","value","previousSelectedItem","indexOf","parsed","String","element","boundedIndex","Math","max","min","previousIndex","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","SingleSelectionDemo"],"mappings":"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","file":"demos.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f0fe6c906c5cec7dfca3","/*\n * This is currently a demo of how multiple mixins cooperate to perform useful\n * functions.\n *\n * * The component uses ShadowTemplateMixin to populate its shadow root.\n * * A user can click on a child item, and ClickSelectionMixin will set the\n *   selected item.\n * * The SingleSelectionMixin will track the selected item, and map that to\n *   changes in the selection state of the selected/deselected items.\n * * The SelectionAriaMixin will reflect an item's selection state using ARIA\n *   attributes to support assistive devices like screen readers.\n *\n * This demo will eventually evolve into a complete list box component, but\n * at the moment omits many features, including support for Page Up/Page Down\n * keys, keeping the selected item in view, the ability to select an item\n * by typing its initial characters, and support for slot elements as children.\n */\n\n\nimport ClickSelectionMixin from '../../elix-mixins/src/ClickSelectionMixin';\nimport SelectionAriaMixin from '../../elix-mixins/src/SelectionAriaMixin';\nimport ShadowTemplateMixin from '../../elix-mixins/src/ShadowTemplateMixin';\nimport SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n// We want to apply a number of mixin functions to HTMLElement.\nconst mixins = [\n  ClickSelectionMixin,\n  SelectionAriaMixin,\n  ShadowTemplateMixin,\n  SingleSelectionMixin\n];\n\n// The mixins are functions, so an efficient way to apply them all is with\n// reduce. This is just function composition. We end up with a base class we\n// can extend below.\nconst base = mixins.reduce((cls, mixin) => mixin(cls), HTMLElement);\n\n\n/**\n * A simple single-selection list box.\n *\n * This uses the base class we just created above, and adds in the behavior\n * unique to this list box element. As it turns out, much of this behavior is\n * also interesting to other components, and will eventually get factored into\n * other mixins.\n *\n * @extends HTMLElement\n * @mixes ClickSelectionMixin\n * @mixes SelectionAriaMixin\n * @mixes ShadowTemplateMixin\n * @mixes SingleSelectionMixin\n */\nclass ListBox extends base {\n\n  constructor() {\n    super();\n\n    // Simplistic keyboard handling for Left/Right and Up/Down keys.\n    this.addEventListener('keydown', event => {\n      this[symbols.raiseChangeEvents] = true;\n      let handled = false;\n      switch(event.keyCode) {\n        case 37: // Left\n        case 38: // Up\n          handled = this.selectPrevious();\n          break;\n        case 39: // Right\n        case 40: // Down\n          handled = this.selectNext();\n          break;\n      }\n      if (handled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      this[symbols.raiseChangeEvents] = false;\n    });\n\n    // The list needs to initialize any items it starts with by invoking the\n    // itemsChanged method. Mixins like the ARIA mixin will then use that signal\n    // to apply attributes to each item, as well as to the list element itself.\n    // For now, we invoke the method manually, but eventually we'll want a mixin\n    // to handle this common need. Because the Custom Element spec prevents an\n    // element from modifying itself in its own constructor, we do so in\n    // timeout.\n    setTimeout(() => {\n      this[symbols.itemsChanged]();\n    });\n  }\n\n  // Map attribute changes to the corresponding property.\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = parseInt(newValue);\n    }\n  }\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    // Set a default tabindex so that the element can receive focus. That lets\n    // us support keyboard selection. We take care to avoid ovewritting any\n    // tabindex that's explicitly set on the list element.\n    if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n      this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n    }\n  }\n\n  // We define a collection of default property values which can be set in\n  // the constructor or connectedCallback. Defining the actual default values\n  // in those calls would complicate things if a subclass someday wants to\n  // define its own default value.\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    // The default tab index is 0 (document order).\n    defaults.tabindex = 0;\n    return defaults;\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of an items property so that SingleSelectionMixin\n  // has items to work with. This doesn't handle Shadow DOM redistribution, so\n  // if someone puts a slot element inside the list, it won't behave as\n  // expected.\n  get items() {\n    return this.children;\n  }\n\n  // A simplistic implementation of itemsChanged. A real implementation\n  // would also need to track changes in the set of children, and invoke\n  // itemAdded for new children.\n  [symbols.itemsChanged]() {\n    Array.prototype.forEach.call(this.items, child => {\n      this[symbols.itemAdded](child);\n    });\n  }\n\n  // Tell the browser which attributes we want to handle.\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n  // Define a template that will be stamped into the Shadow DOM by the\n  // ShadowTemplateMixin.\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      #itemsContainer {\n        flex: 1;\n        -webkit-overflow-scrolling: touch;\n        overflow-y: scroll; /* for momentum scrolling */\n      }\n\n      #itemsContainer ::slotted(*) {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      #itemsContainer ::slotted(.selected) {\n        background: var(--elix-selected-background, highlight);\n        color: var(--elix-selected-color, highlighttext);\n      }\n      </style>\n\n      <div id=\"itemsContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('sample-list-box', ListBox);\nexport default ListBox;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/ListBox.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps a click (actually, a mousedown) to a selection.\n *\n * This simple mixin is useful in list box-like elements, where a click on a\n * list item implicitly selects it.\n *\n * The standard use for this mixin is in list-like elements. Native list\n * boxes don't appear to be consistent with regard to whether they select\n * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n * On touch devices, that event appears to trigger when the touch is *released*.\n *\n * Much has been written about how to ensure \"fast tap\" behavior on mobile\n * devices. This mixin makes a very straightforward use of a standard event, and\n * this appears to perform well on mobile devices when, e.g., the viewport is\n * configured with `width=device-width`.\n *\n * This mixin expects the component to provide an `items` property. It also\n * expects the component to define a `selectedItem` property; you can provide\n * that yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * If the component receives a clicks that doesn't correspond to an item (e.g.,\n * the user clicks on the element background visible between items), the\n * selection will be removed. However, if the component defines a\n * `selectionRequired` and this is true, a background click will *not* remove\n * the selection.\n *\n * @module ClickSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ClickSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('mousedown', event => {\n\n        this[symbols.raiseChangeEvents] = true;\n\n        // If the item clicked on is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET) — but the event target will be the component, not\n        // the item that was clicked on.\n        const target = event.target === this ?\n          event.composedPath()[0] : // Event target isn't the item, so get it from path.\n          event.target;\n\n        // Find which item was clicked on and, if found, select it. For elements\n        // which don't require a selection, a background click will determine\n        // the item was null, in which we case we'll remove the selection.\n        const item = itemForTarget(this, target);\n        if (item || !this.selectionRequired) {\n\n          if (!('selectedItem' in this)) {\n            console.warn(`ClickSelectionMixin expects a component to define a \"selectedItem\" property.`);\n          } else {\n            this.selectedItem = item;\n          }\n\n          // We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n  }\n\n  return ClickSelection;\n}\n\n\n/*\n * Return the list item that is, or contains, the indicated target element.\n * Return null if not found.\n */\nfunction itemForTarget(listElement, target) {\n  const items = listElement.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ClickSelectionMixin.js","import Symbol from './Symbol';\n\n\n/**\n * A collection of (potentially polyfilled) Symbol objects for standard\n * component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: Symbol('defaults'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. For a detailed discussion\n   * of this point, see the Gold Standard checklist item for\n   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n   *\n   * The above article describes a pattern for using a flag to track whether\n   * work is being performed in response to internal component activity, and\n   * whether the component should therefore raise property change events.\n   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n   * all Elix mixins and components. Sharing this flag ensures that internal\n   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n   * handling affected properties to raise change events.\n   *\n   * All UI event listeners (and other forms of internal handlers, such as\n   * timeouts and async network handlers) should set `raiseChangeEvents` to\n   * `true` at the start of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   * @var {boolean} raiseChangeEvents\n   */\n  raiseChangeEvents: Symbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: Symbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   *\n   * @function itemsChanged\n   */\n  itemsChanged: Symbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: Symbol('itemSelected'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLTemplateElement}\n   */\n  template: Symbol('template')\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/symbols.js","/* The number of fake symbols we've served up */\nlet count = 0;\n\nfunction uniqueString(description) {\n  return `_${description}${count++}`;\n}\n\nconst symbolFunction = typeof window.Symbol === 'function' ?\n  window.Symbol :\n  uniqueString;\n\n/**\n * Polyfill for ES6 symbol class.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. In\n * lieu of returning a true Symbol, this polyfill returns a different string\n * each time it is called.\n *\n * Usage:\n *\n *     const fooSymbol = Symbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property that looks\n * like this._foo0. The underscore is meant to reduce (not eliminate) potential\n * accidental access, and the unique number at the end is mean to avoid (not\n * eliminate) naming conflicts.\n *\n * @function Symbol\n * @param {string} description - A string to identify the symbol when debugging\n * @returns {Symbol|string} — A Symbol (in ES6 browsers) or unique string ID (in\n * ES5).\n */\nexport default symbolFunction;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/Symbol.js","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/**\n * Mixin which treats the selected item in a list as the active item in ARIA\n * accessibility terms.\n *\n * Handling ARIA selection state properly is actually quite complex:\n *\n * * The items in the list need to be indicated as possible items via an ARIA\n *   `role` attribute value such as \"option\".\n * * The selected item need to be marked as selected by setting the item's\n *   `aria-selected` attribute to true *and* the other items need be marked as\n *   *not* selected by setting `aria-selected` to false.\n * * The outermost element with the keyboard focus needs to have attributes\n *   set on it so that the selection is knowable at the list level via the\n *   `aria-activedescendant` attribute.\n * * Use of `aria-activedescendant` in turn requires that all items in the\n *   list have ID attributes assigned to them.\n *\n * This mixin tries to address all of the above requirements. To that end,\n * this mixin will assign generated IDs to any item that doesn't already have\n * an ID.\n *\n * ARIA relies on elements to provide `role` attributes. This mixin will apply\n * a default role of \"listbox\" on the outer list if it doesn't already have an\n * explicit role. Similarly, this mixin will apply a default role of \"option\"\n * to any list item that does not already have a role specified.\n *\n * This mixin expects a set of members that manage the state of the selection:\n * `[symbols.itemSelected]`, `[symbols.itemAdded]`, and `selectedItem`. You can\n * supply these yourself, or do so via\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function (base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SelectionAria extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the overall component.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      defaults.itemRole = 'option';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role for an individual item.\n        item.setAttribute('role', this[symbols.defaults].itemRole);\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAria;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SelectionAriaMixin.js","import symbols from '../src/symbols';\n\n\n// A cache of processed templates.\n//\n// We maintain this as a map keyed by element tag (localName). We could store\n// an element's processed template on its element prototype. One scenario that\n// wouldn't support would be registration of the same constructor under multiple\n// tag names, which was a (perhaps theoretical) use case for Custom Elements.\n//\nconst mapTagToTemplate = {};\n\n\n/**\n * Mixin which adds stamping a template into a Shadow DOM subtree upon component\n * instantiation.\n *\n * To use this mixin, define a `template` property as a string or HTML\n * `<template>` element:\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       get [symbols.template]() {\n *         return `Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` property, this\n * mixin has no effect.\n *\n * For the time being, this extension retains support for Shadow DOM v0. That\n * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n * implement Shadow DOM v1.\n *\n * @module ShadowTemplateMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ShadowTemplateMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n\n      const tag = this.localName;\n      let template = mapTagToTemplate[tag];\n\n      // See if we've already processed a template for this tag.\n      if (!template) {\n        // This is the first time we've created an instance of this tag.\n\n        // Get the template and perform initial processing.\n        template = this[symbols.template];\n        if (!template) {\n          console.warn(`ShadowTemplateMixin expects a component to define a template property with [symbols.template].`);\n          return;\n        }\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          const templateText = template;\n          template = document.createElement('template');\n          template.innerHTML = templateText;\n        }\n\n        if (window.ShadyCSS) {\n          // Let the CSS polyfill do its own initialization.\n          window.ShadyCSS.prepareTemplate(template, tag);\n        }\n\n        // Store this for the next time we create the same type of element.\n        mapTagToTemplate[tag] = template;\n      }\n\n      // Stamp the template into a new shadow root.\n      const root = this.attachShadow({ mode: 'open' });\n      const clone = document.importNode(template.content, true);\n      root.appendChild(clone);\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.applyStyle(this);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ShadowTemplateMixin.js","import Symbol from './Symbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = Symbol('canSelectNext');\nconst canSelectPreviousSymbol = Symbol('canSelectPrevious');\nconst selectionRequiredSymbol = Symbol('selectionRequired');\nconst selectionWrapsSymbol = Symbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = Symbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = Symbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = Symbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = Symbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      const parsed = String(selectionRequired) === 'true';\n      const changed = parsed !== this[selectionRequiredSymbol];\n      this[selectionRequiredSymbol] = parsed;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-required-changed');\n          this.dispatchEvent(event);\n        }\n        if (selectionRequired) {\n          trackSelectedItem(this);\n        }\n      }\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(selectionWraps) {\n      const parsed = String(selectionWraps) === 'true';\n      const changed = parsed !== this[selectionWrapsSymbol];\n      this[selectionWrapsSymbol] = parsed;\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = selectionWraps; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-wraps-changed');\n          this.dispatchEvent(event);\n        }\n        updatePossibleNavigations(this);\n      }\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SingleSelectionMixin.js","import SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n/*\n * A very simple component to show the application of SingleSelectionMixin.\n *\n * For a more complete demo using SingleSelectionMixin, see the ListBox demo.\n */\nexport default class SingleSelectionDemo extends SingleSelectionMixin(HTMLElement) {\n\n  constructor() {\n    super();\n    this.addEventListener('mousedown', event => {\n      this[symbols.raiseChangeEvents] = true;\n      this.selectedItem = event.target;\n      event.stopPropagation();\n      this[symbols.raiseChangeEvents] = false;\n    });\n  }\n\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = newValue;\n    }\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of items property — doesn't handle redistribution.\n  get items() {\n    return this.children;\n  }\n\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n}\n\n\ncustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/SingleSelectionDemo.js"],"sourceRoot":""}