{"version":3,"sources":["node_modules/browser-pack/_prelude.js","elements/demos/src/SingleSelectionDemo.js","elements/elix-mixins/src/CustomEvent.js","elements/elix-mixins/src/SingleSelectionMixin.js","elements/elix-mixins/src/createSymbol.js","elements/elix-mixins/src/symbols.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_SingleSelectionMixin2","_symbols","SingleSelectionDemo","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","addEventListener","event","_symbols2","default","raiseChangeEvents","selectedItem","target","stopPropagation","attributeName","oldValue","newValue","_get","prototype","selectedIndex","itemSelected","item","selected","classList","toggle","children","_SingleSelectionMixin3","HTMLElement","customElements","define","customEventPolyfill","eventName","params","bubbles","cancelable","detail","undefined","document","createEvent","initCustomEvent","originalPreventDefault","preventDefault","defineProperty","get","defaultPrevented","customEventConstructor","setPrototypeOf","window","Event","CustomEvent","SingleSelectionMixin","base","SingleSelection","_base","selectionRequired","defaults","selectionWraps","_inherits","_createClass","key","itemAdded","value","itemsChanged","trackSelectedItem","updatePossibleNavigations","selectIndex","items","newIndex","canSelectNextSymbol","set","canSelectNext","changed","_set","dispatchEvent","_CustomEvent2","canSelectPreviousSymbol","canSelectPrevious","externalSelectedIndexSymbol","index","internalSelectedIndexSymbol","parsedIndex","parseInt","hasItems","externalSelectedItemSymbol","internalSelectedItemSymbol","previousSelectedItem","Array","indexOf","selectionRequiredSymbol","selectionWrapsSymbol","String","element","count","boundedIndex","Math","max","min","previousIndex","itemCount","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","_createSymbol","_CustomEvent","_createSymbol2","createSymbol","description","Symbol","symbols"],"mappings":"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","file":"demos.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\nexport default class SingleSelectionDemo extends SingleSelectionMixin(HTMLElement) {\n\n  constructor() {\n    super();\n\n    // When a child is clicked, set the selectedItem.\n    this.addEventListener('click', event => {\n      this[symbols.raiseChangeEvents] = true;\n      this.selectedItem = event.target !== this ?\n        event.target :  // Clicked on an item\n        null;           // Clicked on element background\n      event.stopPropagation();\n      this[symbols.raiseChangeEvents] = false;\n    });\n  }\n\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = newValue;\n    }\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of items property — doesn't handle redistribution.\n  get items() {\n    return this.children;\n  }\n\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n}\n\n\ncustomElements.define('single-selection-demo', SingleSelectionDemo);\n","/*\n * Polyfill for creating CustomEvents for IE 11.\n * Inspired by https://github.com/krambuhl/custom-event-polyfill.\n */\n\nlet customEventConstructor;\n\nfunction customEventPolyfill(eventName, params) {\n  params = params || {\n    bubbles: false,\n    cancelable: false,\n    detail: undefined\n  };\n  const event = document.createEvent(\"CustomEvent\");\n  event.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);\n  const originalPreventDefault = event.preventDefault;\n  event.preventDefault = function() {\n    originalPreventDefault.call(this);\n    try {\n      Object.defineProperty(this, 'defaultPrevented', {\n        get: function () {\n          return true;\n        }\n      });\n    } catch(e) {\n      this.defaultPrevented = true;\n    }\n  };\n\n  return event;\n}\nObject.setPrototypeOf(customEventPolyfill, window.Event.prototype);\n\ntry {\n  new window.CustomEvent('test');\n  customEventConstructor = window.CustomEvent;\n} catch(e) {\n  customEventConstructor = customEventPolyfill;\n}\n\nexport default customEventConstructor;\n","import createSymbol from './createSymbol';\nimport CustomEvent from './CustomEvent';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. This property can be used\n   * to manage events as follows.\n   *\n   * First, UI event listeners should set this property to `true` at the start\n   * of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   */\n  raiseChangeEvents: createSymbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected')\n\n};\n\nexport default symbols;\n"]}