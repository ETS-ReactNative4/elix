{"version":3,"sources":["webpack:///demos.min.js","webpack:///webpack/bootstrap ae23d90ca7b97aee43fc","webpack:///./elements/demos/src/SingleSelectionDemo.js","webpack:///./elements/elix-mixins/src/SingleSelectionMixin.js","webpack:///./elements/elix-mixins/src/createSymbol.js","webpack:///./elements/elix-mixins/src/CustomEvent.js","webpack:///./elements/elix-mixins/src/symbols.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","_SingleSelectionMixin2","_SingleSelectionMixin3","_symbols","_symbols2","SingleSelectionDemo","_SingleSelectionMixin","this","_this","addEventListener","event","raiseChangeEvents","selectedItem","stopPropagation","attributeName","oldValue","newValue","selectedIndex","itemSelected","item","selected","classList","toggle","children","HTMLElement","customElements","define","SingleSelectionMixin","base","SingleSelection","_base","selectionRequired","defaults","selectionWraps","itemAdded","itemsChanged","trackSelectedItem","updatePossibleNavigations","selectIndex","items","newIndex","canSelectNextSymbol","set","canSelectNext","changed","_set","dispatchEvent","_CustomEvent2","canSelectPreviousSymbol","canSelectPrevious","externalSelectedIndexSymbol","index","internalSelectedIndexSymbol","parsedIndex","parseInt","hasItems","externalSelectedItemSymbol","detail","internalSelectedItemSymbol","previousSelectedItem","Array","indexOf","selectionRequiredSymbol","selectionWrapsSymbol","String","element","count","boundedIndex","Math","max","min","previousIndex","itemCount","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","setter","_createSymbol","_createSymbol2","_CustomEvent","createSymbol","description","Symbol","customEventPolyfill","eventName","params","bubbles","cancelable","document","createEvent","initCustomEvent","originalPreventDefault","preventDefault","e","defaultPrevented","customEventConstructor","window","Event","CustomEvent","symbols"],"mappings":"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","file":"demos.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _SingleSelectionMixin2 = __webpack_require__(2);\n\t\n\tvar _SingleSelectionMixin3 = _interopRequireDefault(_SingleSelectionMixin2);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar SingleSelectionDemo = function (_SingleSelectionMixin) {\n\t  _inherits(SingleSelectionDemo, _SingleSelectionMixin);\n\t\n\t  function SingleSelectionDemo() {\n\t    _classCallCheck(this, SingleSelectionDemo);\n\t\n\t    // When a child is clicked, set the selectedItem.\n\t    var _this = _possibleConstructorReturn(this, (SingleSelectionDemo.__proto__ || Object.getPrototypeOf(SingleSelectionDemo)).call(this));\n\t\n\t    _this.addEventListener('click', function (event) {\n\t      _this[_symbols2.default.raiseChangeEvents] = true;\n\t      _this.selectedItem = event.target !== _this ? event.target : // Clicked on an item\n\t      null; // Clicked on element background\n\t      event.stopPropagation();\n\t      _this[_symbols2.default.raiseChangeEvents] = false;\n\t    });\n\t    return _this;\n\t  }\n\t\n\t  _createClass(SingleSelectionDemo, [{\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(attributeName, oldValue, newValue) {\n\t      if (_get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), 'attributeChangedCallback', this)) {\n\t        _get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), 'attributeChangedCallback', this).call(this, attributeName, oldValue, newValue);\n\t      }\n\t      if (attributeName === 'selected-index') {\n\t        this.selectedIndex = newValue;\n\t      }\n\t    }\n\t\n\t    // Map item selection to a `selected` CSS class.\n\t\n\t  }, {\n\t    key: _symbols2.default.itemSelected,\n\t    value: function value(item, selected) {\n\t      if (_get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), _symbols2.default.itemSelected, this)) {\n\t        _get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t      }\n\t      item.classList.toggle('selected', selected);\n\t    }\n\t\n\t    // Simplistic implementation of items property — doesn't handle redistribution.\n\t\n\t  }, {\n\t    key: 'items',\n\t    get: function get() {\n\t      return this.children;\n\t    }\n\t  }], [{\n\t    key: 'observedAttributes',\n\t    get: function get() {\n\t      return ['selected-index'];\n\t    }\n\t  }]);\n\t\n\t  return SingleSelectionDemo;\n\t}((0, _SingleSelectionMixin3.default)(HTMLElement));\n\t\n\texports.default = SingleSelectionDemo;\n\t\n\t\n\tcustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\texports.default = SingleSelectionMixin;\n\t\n\tvar _createSymbol = __webpack_require__(3);\n\t\n\tvar _createSymbol2 = _interopRequireDefault(_createSymbol);\n\t\n\tvar _CustomEvent = __webpack_require__(4);\n\t\n\tvar _CustomEvent2 = _interopRequireDefault(_CustomEvent);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// Symbols for private data members on an element.\n\tvar canSelectNextSymbol = (0, _createSymbol2.default)('canSelectNext');\n\tvar canSelectPreviousSymbol = (0, _createSymbol2.default)('canSelectPrevious');\n\tvar selectionRequiredSymbol = (0, _createSymbol2.default)('selectionRequired');\n\tvar selectionWrapsSymbol = (0, _createSymbol2.default)('selectionWraps');\n\t\n\t// We want to expose both selectedIndex and selectedItem as independent\n\t// properties but keep them in sync. This allows a component user to reference\n\t// the selection by whatever means is most natural for their situation.\n\t//\n\t// To efficiently keep these properties in sync, we track \"external\" and\n\t// \"internal\" references for each property:\n\t//\n\t// The external index or item is the one we report to the outside world when\n\t// asked for selection.  When handling a change to index or item, we update the\n\t// external reference as soon as possible, so that if anyone immediately asks\n\t// for the current selection, they will receive a stable answer.\n\t//\n\t// The internal index or item tracks whichever index or item last received the\n\t// full set of processing. Processing includes raising a change event for the\n\t// new value. Once we've begun that processing, we store the new value as the\n\t// internal value to indicate we've handled it.\n\t//\n\tvar externalSelectedIndexSymbol = (0, _createSymbol2.default)('externalSelectedIndex');\n\tvar externalSelectedItemSymbol = (0, _createSymbol2.default)('externalSelectedItem');\n\tvar internalSelectedIndexSymbol = (0, _createSymbol2.default)('internalSelectedIndex');\n\tvar internalSelectedItemSymbol = (0, _createSymbol2.default)('internalSelectedItem');\n\t\n\t/**\n\t * Mixin which adds single-selection semantics for items in a list.\n\t *\n\t * This mixin expects a component to provide an `items` Array or NodeList of\n\t * all elements in the list.\n\t *\n\t * This mixin tracks a single selected item in the list, and provides means to\n\t * get and set that state by item position (`selectedIndex`) or item identity\n\t * (`selectedItem`). The selection can be moved in the list via the methods\n\t * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n\t *\n\t * This mixin does not produce any user-visible effects to represent\n\t * selection.\n\t *\n\t * @module SingleSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction SingleSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var SingleSelection = function (_base) {\n\t    _inherits(SingleSelection, _base);\n\t\n\t    function SingleSelection() {\n\t      _classCallCheck(this, SingleSelection);\n\t\n\t      // Set defaults.\n\t      var _this = _possibleConstructorReturn(this, (SingleSelection.__proto__ || Object.getPrototypeOf(SingleSelection)).call(this));\n\t\n\t      if (typeof _this.selectionRequired === 'undefined') {\n\t        _this.selectionRequired = _this[_symbols2.default.defaults].selectionRequired;\n\t      }\n\t      if (typeof _this.selectionWraps === 'undefined') {\n\t        _this.selectionWraps = _this[_symbols2.default.defaults].selectionWraps;\n\t      }\n\t      return _this;\n\t    }\n\t\n\t    /**\n\t     * True if the selection can be moved to the next item, false if not (the\n\t     * selected item is the last item in the list).\n\t     *\n\t     * @type {boolean}\n\t     */\n\t\n\t\n\t    _createClass(SingleSelection, [{\n\t      key: _symbols2.default.itemAdded,\n\t\n\t\n\t      /**\n\t       * Handle a new item being added to the list.\n\t       *\n\t       * The default implementation of this method simply sets the item's\n\t       * selection state to false.\n\t       *\n\t       * @param {HTMLElement} item - the item being added\n\t       */\n\t      value: function value(item) {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemAdded, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemAdded, this).call(this, item);\n\t        }\n\t        this[_symbols2.default.itemSelected](item, item === this.selectedItem);\n\t      }\n\t    }, {\n\t      key: _symbols2.default.itemsChanged,\n\t      value: function value() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemsChanged, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemsChanged, this).call(this);\n\t        }\n\t\n\t        // In case selected item changed position or was removed.\n\t        trackSelectedItem(this);\n\t\n\t        // In case the change in items affected which navigations are possible.\n\t        updatePossibleNavigations(this);\n\t      }\n\t\n\t      /**\n\t       * Apply the indicate selection state to the item.\n\t       *\n\t       * The default implementation of this method does nothing. User-visible\n\t       * effects will typically be handled by other mixins.\n\t       *\n\t       * @param {HTMLElement} item - the item being selected/deselected\n\t       * @param {boolean} selected - true if the item is selected, false if not\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.itemSelected,\n\t      value: function value(item, selected) {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemSelected, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * The index of the item which is currently selected.\n\t       *\n\t       * The setter expects an integer or a string representing an integer.\n\t       *\n\t       * A `selectedIndex` of -1 indicates there is no selection. Setting this\n\t       * property to -1 will remove any existing selection.\n\t       *\n\t       * @type {number}\n\t       */\n\t\n\t    }, {\n\t      key: 'selectFirst',\n\t\n\t\n\t      /**\n\t       * Select the first item in the list.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t      value: function selectFirst() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectFirst', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectFirst', this).call(this);\n\t        }\n\t        return selectIndex(this, 0);\n\t      }\n\t\n\t      /**\n\t       * True if the list should always have a selection (if it has items).\n\t       *\n\t       * @type {boolean}\n\t       * @default false\n\t       */\n\t\n\t    }, {\n\t      key: 'selectLast',\n\t\n\t\n\t      /**\n\t       * Select the last item in the list.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t      value: function selectLast() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectLast', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectLast', this).call(this);\n\t        }\n\t        return selectIndex(this, this.items.length - 1);\n\t      }\n\t\n\t      /**\n\t       * Select the next item in the list.\n\t       *\n\t       * If the list has no selection, the first item will be selected.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t\n\t    }, {\n\t      key: 'selectNext',\n\t      value: function selectNext() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectNext', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectNext', this).call(this);\n\t        }\n\t        return selectIndex(this, this.selectedIndex + 1);\n\t      }\n\t\n\t      /**\n\t       * Select the previous item in the list.\n\t       *\n\t       * If the list has no selection, the last item will be selected.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t\n\t    }, {\n\t      key: 'selectPrevious',\n\t      value: function selectPrevious() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectPrevious', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectPrevious', this).call(this);\n\t        }\n\t        var newIndex = this.selectedIndex < 0 ? this.items.length - 1 : // No selection yet; select last item.\n\t        this.selectedIndex - 1;\n\t        return selectIndex(this, newIndex);\n\t      }\n\t\n\t      /**\n\t       * Fires when the canSelectNext property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event can-select-next-changed\n\t       */\n\t\n\t      /**\n\t       * Fires when the canSelectPrevious property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event can-select-previous-changed\n\t       */\n\t\n\t      /**\n\t       * Fires when the selectedIndex property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event selected-index-changed\n\t       * @param {number} detail.selectedIndex The new selected index.\n\t       */\n\t\n\t      /**\n\t       * Fires when the selectedItem property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event selected-item-changed\n\t       * @param {HTMLElement} detail.selectedItem The new selected item.\n\t       */\n\t\n\t    }, {\n\t      key: 'canSelectNext',\n\t      get: function get() {\n\t        return this[canSelectNextSymbol];\n\t      },\n\t      set: function set(canSelectNext) {\n\t        var changed = canSelectNext !== this[canSelectNextSymbol];\n\t        this[canSelectNextSymbol] = canSelectNext;\n\t        if ('canSelectNext' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'canSelectNext', canSelectNext, this);\n\t        }\n\t        if (this[_symbols2.default.raiseChangeEvents] && changed) {\n\t          this.dispatchEvent(new _CustomEvent2.default('can-select-next-changed'));\n\t        }\n\t      }\n\t\n\t      /**\n\t       * True if the selection can be moved to the previous item, false if not\n\t       * (the selected item is the first one in the list).\n\t       *\n\t       * @type {boolean}\n\t       */\n\t\n\t    }, {\n\t      key: 'canSelectPrevious',\n\t      get: function get() {\n\t        return this[canSelectPreviousSymbol];\n\t      },\n\t      set: function set(canSelectPrevious) {\n\t        var changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n\t        this[canSelectPreviousSymbol] = canSelectPrevious;\n\t        if ('canSelectPrevious' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'canSelectPrevious', canSelectPrevious, this);\n\t        }\n\t        if (this[_symbols2.default.raiseChangeEvents] && changed) {\n\t          this.dispatchEvent(new _CustomEvent2.default('can-select-previous-changed'));\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.defaults,\n\t      get: function get() {\n\t        var defaults = _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.defaults, this) || {};\n\t        defaults.selectionRequired = false;\n\t        defaults.selectionWraps = false;\n\t        return defaults;\n\t      }\n\t    }, {\n\t      key: 'selectedIndex',\n\t      get: function get() {\n\t        return this[externalSelectedIndexSymbol] != null ? this[externalSelectedIndexSymbol] : -1;\n\t      },\n\t      set: function set(index) {\n\t        // See notes at top about internal vs. external copies of this property.\n\t        var changed = index !== this[internalSelectedIndexSymbol];\n\t        var item = void 0;\n\t        var parsedIndex = parseInt(index);\n\t        if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n\t          // Store the new index and the corresponding item.\n\t          var items = this.items;\n\t          var hasItems = items && items.length > 0;\n\t          if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n\t            parsedIndex = -1; // No item at that index.\n\t          }\n\t          this[externalSelectedIndexSymbol] = parsedIndex;\n\t          item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n\t          this[externalSelectedItemSymbol] = item;\n\t        } else {\n\t          item = this[externalSelectedItemSymbol];\n\t        }\n\t\n\t        // Now let super do any work.\n\t        if ('selectedIndex' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectedIndex', index, this);\n\t        }\n\t\n\t        if (changed) {\n\t          // The selected index changed.\n\t          this[internalSelectedIndexSymbol] = parsedIndex;\n\t\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new _CustomEvent2.default('selected-index-changed', {\n\t              detail: {\n\t                selectedIndex: parsedIndex,\n\t                value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n\t              }\n\t            });\n\t            this.dispatchEvent(event);\n\t          }\n\t        }\n\t\n\t        if (this[internalSelectedItemSymbol] !== item) {\n\t          // Update selectedItem property so it can have its own effects.\n\t          this.selectedItem = item;\n\t        }\n\t      }\n\t\n\t      /**\n\t       * The currently selected item, or null if there is no selection.\n\t       *\n\t       * Setting this property to null deselects any currently-selected item.\n\t       * Setting this property to an object that is not in the list has no effect.\n\t       *\n\t       * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n\t       * TODO: If selectionRequired, leave selection alone?\n\t       *\n\t       * @type {object}\n\t       */\n\t\n\t    }, {\n\t      key: 'selectedItem',\n\t      get: function get() {\n\t        return this[externalSelectedItemSymbol] || null;\n\t      },\n\t      set: function set(item) {\n\t        // See notes at top about internal vs. external copies of this property.\n\t        var previousSelectedItem = this[internalSelectedItemSymbol];\n\t        var changed = item !== previousSelectedItem;\n\t        var index = void 0;\n\t        if (item !== this[externalSelectedItemSymbol]) {\n\t          // Store item and look up corresponding index.\n\t          var items = this.items;\n\t          var hasItems = items && items.length > 0;\n\t          index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n\t          this[externalSelectedIndexSymbol] = index;\n\t          if (index < 0) {\n\t            item = null; // The indicated item isn't actually in `items`.\n\t          }\n\t          this[externalSelectedItemSymbol] = item;\n\t        } else {\n\t          index = this[externalSelectedIndexSymbol];\n\t        }\n\t\n\t        // Now let super do any work.\n\t        if ('selectedItem' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectedItem', item, this);\n\t        }\n\t\n\t        if (changed) {\n\t          // The selected item changed.\n\t          this[internalSelectedItemSymbol] = item;\n\t\n\t          if (previousSelectedItem) {\n\t            // Update selection state of old item.\n\t            this[_symbols2.default.itemSelected](previousSelectedItem, false);\n\t          }\n\t          if (item) {\n\t            // Update selection state to new item.\n\t            this[_symbols2.default.itemSelected](item, true);\n\t          }\n\t\n\t          updatePossibleNavigations(this);\n\t\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new _CustomEvent2.default('selected-item-changed', {\n\t              detail: {\n\t                selectedItem: item,\n\t                value: item // for Polymer binding\n\t              }\n\t            });\n\t            this.dispatchEvent(event);\n\t          }\n\t        }\n\t\n\t        if (this[internalSelectedIndexSymbol] !== index) {\n\t          // Update selectedIndex property so it can have its own effects.\n\t          this.selectedIndex = index;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'selectionRequired',\n\t      get: function get() {\n\t        return this[selectionRequiredSymbol];\n\t      },\n\t      set: function set(selectionRequired) {\n\t        this[selectionRequiredSymbol] = selectionRequired;\n\t        if ('selectionRequired' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectionRequired', selectionRequired, this);\n\t        }\n\t        trackSelectedItem(this);\n\t      }\n\t\n\t      /**\n\t       * True if selection navigations wrap from last to first, and vice versa.\n\t       *\n\t       * @type {boolean}\n\t       * @default false\n\t       */\n\t\n\t    }, {\n\t      key: 'selectionWraps',\n\t      get: function get() {\n\t        return this[selectionWrapsSymbol];\n\t      },\n\t      set: function set(value) {\n\t        this[selectionWrapsSymbol] = String(value) === 'true';\n\t        if ('selectionWraps' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectionWraps', value, this);\n\t        }\n\t        updatePossibleNavigations(this);\n\t      }\n\t    }]);\n\t\n\t    return SingleSelection;\n\t  }(base);\n\t\n\t  return SingleSelection;\n\t}\n\t\n\t// Ensure the given index is within bounds, and select it if it's not already\n\t// selected.\n\tfunction selectIndex(element, index) {\n\t\n\t  var items = element.items;\n\t  if (items == null) {\n\t    // Nothing to select.\n\t    return false;\n\t  }\n\t\n\t  var count = items.length;\n\t  var boundedIndex = element.selectionWraps ?\n\t  // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n\t  // See http://stackoverflow.com/a/18618250/76472\n\t  (index % count + count) % count :\n\t\n\t  // Keep index within bounds of array.\n\t  Math.max(Math.min(index, count - 1), 0);\n\t\n\t  var previousIndex = element.selectedIndex;\n\t  if (previousIndex !== boundedIndex) {\n\t    element.selectedIndex = boundedIndex;\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\t\n\t// Following a change in the set of items, or in the value of the\n\t// `selectionRequired` property, reacquire the selected item. If it's moved,\n\t// update `selectedIndex`. If it's been removed, and a selection is required,\n\t// try to select another item.\n\tfunction trackSelectedItem(element) {\n\t\n\t  var items = element.items;\n\t  var itemCount = items ? items.length : 0;\n\t\n\t  var previousSelectedItem = element.selectedItem;\n\t  if (!previousSelectedItem) {\n\t    // No item was previously selected.\n\t    if (element.selectionRequired) {\n\t      // Select the first item by default.\n\t      element.selectedIndex = 0;\n\t    }\n\t  } else if (itemCount === 0) {\n\t    // We've lost the selection, and there's nothing left to select.\n\t    element.selectedItem = null;\n\t  } else {\n\t    // Try to find the previously-selected item in the current set of items.\n\t    var indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n\t    var previousSelectedIndex = element.selectedIndex;\n\t    if (indexInCurrentItems < 0) {\n\t      // Previously-selected item was removed from the items.\n\t      // Select the item at the same index (if it exists) or as close as possible.\n\t      var newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n\t      // Select by item, since index may be the same, and we want to raise the\n\t      // selected-item-changed event.\n\t      element.selectedItem = items[newSelectedIndex];\n\t    } else if (indexInCurrentItems !== previousSelectedIndex) {\n\t      // Previously-selected item still there, but changed position.\n\t      element.selectedIndex = indexInCurrentItems;\n\t    }\n\t  }\n\t}\n\t\n\t// Following a change in selection, report whether it's now possible to\n\t// go next/previous from the given index.\n\tfunction updatePossibleNavigations(element) {\n\t  var canSelectNext = void 0;\n\t  var canSelectPrevious = void 0;\n\t  var items = element.items;\n\t  if (items == null || items.length === 0) {\n\t    // No items to select.\n\t    canSelectNext = false;\n\t    canSelectPrevious = false;\n\t  } else if (element.selectionWraps) {\n\t    // Since there are items, can always go next/previous.\n\t    canSelectNext = true;\n\t    canSelectPrevious = true;\n\t  } else {\n\t    var index = element.selectedIndex;\n\t    if (index < 0 && items.length > 0) {\n\t      // Special case. If there are items but no selection, declare that it's\n\t      // always possible to go next/previous to create a selection.\n\t      canSelectNext = true;\n\t      canSelectPrevious = true;\n\t    } else {\n\t      // Normal case: we have an index in a list that has items.\n\t      canSelectPrevious = index > 0;\n\t      canSelectNext = index < items.length - 1;\n\t    }\n\t  }\n\t  if (element.canSelectNext !== canSelectNext) {\n\t    element.canSelectNext = canSelectNext;\n\t  }\n\t  if (element.canSelectPrevious !== canSelectPrevious) {\n\t    element.canSelectPrevious = canSelectPrevious;\n\t  }\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = createSymbol;\n\t/**\n\t * Helper function to create a symbol that can be used for associating private\n\t * data with an element.\n\t *\n\t * Mixins and component classes often want to associate private data with an\n\t * element instance, but JavaScript does not have direct support for true\n\t * private properties. One approach is to use the\n\t * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n\t * data type to set and retrieve data on an element.\n\t *\n\t * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n\t * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n\t * returning a true Symbol, it simply returns an underscore-prefixed string.\n\t *\n\t * Usage:\n\t *\n\t *     const fooSymbol = createSymbol('foo');\n\t *\n\t *     class MyElement extends HTMLElement {\n\t *       get foo() {\n\t *         return this[fooSymbol];\n\t *       }\n\t *       set foo(value) {\n\t *         this[fooSymbol] = value;\n\t *       }\n\t *     }\n\t *\n\t * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n\t * The use of the underscore is meant to reduce (not eliminate) the potential\n\t * for name conflicts, and discourage (not prevent) external access to this\n\t * data. In modern browsers, the above code will eliminate the potential of\n\t * naming conflicts, and better hide the data behind a real Symbol.\n\t *\n\t * @function createSymbol\n\t * @param {string} description - A string to identify the symbol when debugging\n\t */\n\tfunction createSymbol(description) {\n\t  return typeof Symbol === 'function' ? Symbol(description) : '_' + description;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/*\n\t * Polyfill for creating CustomEvents for IE 11.\n\t * Inspired by https://github.com/krambuhl/custom-event-polyfill.\n\t */\n\t\n\tvar customEventConstructor = void 0;\n\t\n\tfunction customEventPolyfill(eventName, params) {\n\t  params = params || {\n\t    bubbles: false,\n\t    cancelable: false,\n\t    detail: undefined\n\t  };\n\t  var event = document.createEvent(\"CustomEvent\");\n\t  event.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);\n\t  var originalPreventDefault = event.preventDefault;\n\t  event.preventDefault = function () {\n\t    originalPreventDefault.call(this);\n\t    try {\n\t      Object.defineProperty(this, 'defaultPrevented', {\n\t        get: function get() {\n\t          return true;\n\t        }\n\t      });\n\t    } catch (e) {\n\t      this.defaultPrevented = true;\n\t    }\n\t  };\n\t\n\t  return event;\n\t}\n\tObject.setPrototypeOf(customEventPolyfill, window.Event.prototype);\n\t\n\ttry {\n\t  new window.CustomEvent('test');\n\t  customEventConstructor = window.CustomEvent;\n\t} catch (e) {\n\t  customEventConstructor = customEventPolyfill;\n\t}\n\t\n\texports.default = customEventConstructor;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createSymbol = __webpack_require__(3);\n\t\n\tvar _createSymbol2 = _interopRequireDefault(_createSymbol);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * A collection of Symbol objects for standard component properties and methods.\n\t *\n\t * These Symbol objects are used to allow mixins and a component to internally\n\t * communicate, without exposing these properties and methods in the component's\n\t * public API.\n\t *\n\t * To use these Symbol objects in your own component, include this module and\n\t * then create a property or method whose key is the desired Symbol.\n\t *\n\t *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n\t *     import 'symbols' from 'elix-mixins/src/symbols';\n\t *\n\t *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n\t *       [symbols.itemSelected](item, selected) {\n\t *         // This will be invoked whenever an item is selected/deselected.\n\t *       }\n\t *     }\n\t *\n\t * @module symbols\n\t */\n\tvar symbols = {\n\t\n\t  /**\n\t   * Symbol for the `defaults` property.\n\t   *\n\t   * This property can be used to set or override defaults that will be applied\n\t   * to a new component instance. When implementing this property, take care to\n\t   * first acquire any defaults defined by the superclass. The standard idiom is\n\t   * as follows:\n\t   *\n\t   *     get [symbols.defaults]() {\n\t   *       const defaults = super[symbols.defaults] || {};\n\t   *       // Set or override default values here\n\t   *       defaults.customProperty = false;\n\t   *       return defaults;\n\t   *     }\n\t   *\n\t   * @var {object} defaults\n\t   */\n\t  defaults: (0, _createSymbol2.default)('defaults'),\n\t\n\t  /**\n\t   * Symbol for the `raiseChangeEvents` property.\n\t   *\n\t   * This property is used by mixins to determine whether they should raise\n\t   * property change events. The standard HTML pattern is to only raise such\n\t   * events in response to direct user interactions. This property can be used\n\t   * to manage events as follows.\n\t   *\n\t   * First, UI event listeners should set this property to `true` at the start\n\t   * of the event handler, then `false` at the end:\n\t   *\n\t   *     this.addEventListener('click', event => {\n\t   *       this[symbols.raiseChangeEvents] = true;\n\t   *       // Do work here, possibly setting properties, like:\n\t   *       this.foo = 'Hello';\n\t   *       this[symbols.raiseChangeEvents] = false;\n\t   *     });\n\t   *\n\t   * Elsewhere, property setters that raise change events should only do so it\n\t   * this property is `true`:\n\t   *\n\t   *     set foo(value) {\n\t   *       // Save foo value here, do any other work.\n\t   *       if (this[symbols.raiseChangeEvents]) {\n\t   *         const event = new CustomEvent('foo-changed');\n\t   *         this.dispatchEvent(event);\n\t   *       }\n\t   *     }\n\t   *\n\t   * In this way, programmatic attempts to set the `foo` property will not\n\t   * trigger the `foo-changed` event, but UI interactions that update that\n\t   * property will cause those events to be raised.\n\t   *\n\t   */\n\t  raiseChangeEvents: (0, _createSymbol2.default)('raiseChangeEvents'),\n\t\n\t  /**\n\t   * Symbol for the `itemAdded` method.\n\t   *\n\t   * This method is invoked when a new item is added to a list.\n\t   *\n\t   * @function itemAdded\n\t   * @param {HTMLElement} item - the item being selected/deselected\n\t   */\n\t  itemAdded: (0, _createSymbol2.default)('itemAdded'),\n\t\n\t  /**\n\t   * Symbol for the `itemsChanged` method.\n\t   *\n\t   * This method is invoked when the underlying contents change. It is also\n\t   * invoked on component initialization – since the items have \"changed\" from\n\t   * being nothing.\n\t   */\n\t  itemsChanged: (0, _createSymbol2.default)('itemsChanged'),\n\t\n\t  /**\n\t   * Symbol for the `itemSelected` method.\n\t   *\n\t   * This method is invoked when an item becomes selected or deselected.\n\t   *\n\t   * @function itemSelected\n\t   * @param {HTMLElement} item - the item being selected/deselected\n\t   * @param {boolean} selected - true if the item is selected, false if not\n\t   */\n\t  itemSelected: (0, _createSymbol2.default)('itemSelected')\n\t\n\t};\n\t\n\texports.default = symbols;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// demos.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ae23d90ca7b97aee43fc","import SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\nexport default class SingleSelectionDemo extends SingleSelectionMixin(HTMLElement) {\n\n  constructor() {\n    super();\n\n    // When a child is clicked, set the selectedItem.\n    this.addEventListener('click', event => {\n      this[symbols.raiseChangeEvents] = true;\n      this.selectedItem = event.target !== this ?\n        event.target :  // Clicked on an item\n        null;           // Clicked on element background\n      event.stopPropagation();\n      this[symbols.raiseChangeEvents] = false;\n    });\n  }\n\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = newValue;\n    }\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of items property — doesn't handle redistribution.\n  get items() {\n    return this.children;\n  }\n\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n}\n\n\ncustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/SingleSelectionDemo.js","import createSymbol from './createSymbol';\nimport CustomEvent from './CustomEvent';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SingleSelectionMixin.js","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/createSymbol.js","/*\n * Polyfill for creating CustomEvents for IE 11.\n * Inspired by https://github.com/krambuhl/custom-event-polyfill.\n */\n\nlet customEventConstructor;\n\nfunction customEventPolyfill(eventName, params) {\n  params = params || {\n    bubbles: false,\n    cancelable: false,\n    detail: undefined\n  };\n  const event = document.createEvent(\"CustomEvent\");\n  event.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);\n  const originalPreventDefault = event.preventDefault;\n  event.preventDefault = function() {\n    originalPreventDefault.call(this);\n    try {\n      Object.defineProperty(this, 'defaultPrevented', {\n        get: function () {\n          return true;\n        }\n      });\n    } catch(e) {\n      this.defaultPrevented = true;\n    }\n  };\n\n  return event;\n}\nObject.setPrototypeOf(customEventPolyfill, window.Event.prototype);\n\ntry {\n  new window.CustomEvent('test');\n  customEventConstructor = window.CustomEvent;\n} catch(e) {\n  customEventConstructor = customEventPolyfill;\n}\n\nexport default customEventConstructor;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/CustomEvent.js","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. This property can be used\n   * to manage events as follows.\n   *\n   * First, UI event listeners should set this property to `true` at the start\n   * of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   */\n  raiseChangeEvents: createSymbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected')\n\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/symbols.js"],"sourceRoot":""}