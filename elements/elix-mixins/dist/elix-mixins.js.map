{"version":3,"sources":["node_modules/browser-pack/_prelude.js","elements/elix-mixins/globals.js","elements/elix-mixins/src/CustomEvent.js","elements/elix-mixins/src/SimpleAttributeMixin.js","elements/elix-mixins/src/SimpleTemplateMixin.js","elements/elix-mixins/src/SingleSelectionMixin.js","elements/elix-mixins/src/createSymbol.js","elements/elix-mixins/src/microtask.js","elements/elix-mixins/src/symbols.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_microtask","_SimpleAttributeMixin","_SimpleTemplateMixin","_SingleSelectionMixin","_symbols","window","Elix","microtask","_microtask2","default","SimpleAttributeMixin","_SimpleAttributeMixin2","SimpleTemplateMixin","_SimpleTemplateMixin2","SingleSelectionMixin","_SingleSelectionMixin2","symbols","_symbols2","customEventPolyfill","eventName","params","bubbles","cancelable","detail","undefined","event","document","createEvent","initCustomEvent","originalPreventDefault","preventDefault","this","Object","defineProperty","get","defaultPrevented","customEventConstructor","setPrototypeOf","Event","prototype","CustomEvent","base","SimpleAttribute","_base","_classCallCheck","_possibleConstructorReturn","__proto__","getPrototypeOf","apply","arguments","_inherits","_createClass","key","value","attributeName","oldValue","newValue","_get","HTMLElement","attribute","SimpleTemplate","_this","template","root","attachShadow","mode","innerHTML","className","SingleSelection","selectionRequired","defaults","selectionWraps","itemAdded","item","itemSelected","selectedItem","itemsChanged","trackSelectedItem","updatePossibleNavigations","selected","selectIndex","items","selectedIndex","newIndex","canSelectNextSymbol","set","canSelectNext","changed","_set","raiseChangeEvents","dispatchEvent","_CustomEvent2","canSelectPreviousSymbol","canSelectPrevious","externalSelectedIndexSymbol","index","internalSelectedIndexSymbol","parsedIndex","parseInt","hasItems","externalSelectedItemSymbol","internalSelectedItemSymbol","previousSelectedItem","Array","indexOf","selectionRequiredSymbol","selectionWrapsSymbol","String","element","count","boundedIndex","Math","max","min","previousIndex","itemCount","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","_createSymbol","_CustomEvent","_createSymbol2","createSymbol","description","Symbol","callback","callbacks","push","textContent","counter","executeCallbacks","shift","createTextNode","observer","MutationObserver","observe","characterData"],"mappings":"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","file":"elix-mixins.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport microtask from './src/microtask';\nimport SimpleAttributeMixin from './src/SimpleAttributeMixin';\nimport SimpleTemplateMixin from './src/SimpleTemplateMixin';\nimport SingleSelectionMixin from './src/SingleSelectionMixin';\nimport symbols from './src/symbols';\n\nwindow.Elix = window.Elix || {};\n\nwindow.Elix.microtask = microtask;\nwindow.Elix.SimpleAttributeMixin = SimpleAttributeMixin;\nwindow.Elix.SimpleTemplateMixin = SimpleTemplateMixin;\nwindow.Elix.SingleSelectionMixin = SingleSelectionMixin;\nwindow.Elix.symbols = symbols;\n","/*\n * Polyfill for creating CustomEvents for IE 11.\n * Inspired by https://github.com/krambuhl/custom-event-polyfill.\n */\n\nlet customEventConstructor;\n\nfunction customEventPolyfill(eventName, params) {\n  params = params || {\n    bubbles: false,\n    cancelable: false,\n    detail: undefined\n  };\n  const event = document.createEvent(\"CustomEvent\");\n  event.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);\n  const originalPreventDefault = event.preventDefault;\n  event.preventDefault = function() {\n    originalPreventDefault.call(this);\n    try {\n      Object.defineProperty(this, 'defaultPrevented', {\n        get: function () {\n          return true;\n        }\n      });\n    } catch(e) {\n      this.defaultPrevented = true;\n    }\n  };\n\n  return event;\n}\nObject.setPrototypeOf(customEventPolyfill, window.Event.prototype);\n\ntry {\n  new window.CustomEvent('test');\n  customEventConstructor = window.CustomEvent;\n} catch(e) {\n  customEventConstructor = customEventPolyfill;\n}\n\nexport default customEventConstructor;\n","/**\n * Mixin which adds simplistic mapping of attributes to properties.\n *\n * @module SimpleAttributeMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SimpleAttributeMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SimpleAttribute extends base {\n    \n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n  \t  if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n  \t  // If the attribute name corresponds to a property name, set the property.\n  \t  // Ignore standard HTMLElement properties handled by the DOM.\n  \t  if (attributeName in this && !(attributeName in HTMLElement.prototype)) {\n          this[attributeName] = newValue;\n  \t  }\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      // For documentation purposes only\n    }\n\n  }\n\n  return SimpleAttribute;\n}\n","/**\n * Mixin which adds a simplistic means of cloning a string template into a new\n * shadow root.\n *\n * @module SimpleTemplateMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SimpleTemplateMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SimpleTemplate extends base {\n\n    constructor() {\n\t    super();\n\t    const template = this.template;\n\t    if (template) {\n        const root = this.attachShadow({ mode: 'open' });\n        root.innerHTML = template;\n\t    }\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      // For documentation purposes only\n    }\n\n  }\n\n  return SimpleTemplate;\n}\n","import createSymbol from './createSymbol';\nimport CustomEvent from './CustomEvent';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. This property can be used\n   * to manage events as follows.\n   *\n   * First, UI event listeners should set this property to `true` at the start\n   * of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   */\n  raiseChangeEvents: createSymbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected')\n\n};\n\nexport default symbols;\n"]}