// Create the top-level elix.js and elix.d.ts files.

const fs = require("fs").promises;
const path = require("path");

const srcJsHeader = `/*
 * The complete set of Elix elements and mixins.
 * 
 * This file is the primary entry point to the Elix package, so its exports are
 * what is obtained if you write \`import * from "elix"\`. However, in
 * production use it will be much more efficient to directly load just the
 * components you need from the /src folder. This file is also used during
 * testing, as it causes all Elix's elements to be loaded.
 * 
 * NOTE: Do not edit this file by hand. This file is generated during
 * publishing, or you can regenerate it with \`npm run prepublishOnly\`.
 */`;

const defineJsHeader = `/*
* The complete set of Elix elements and mixins.
* 
* You can load this file as a convenience to auto-define all Elix components
* for immediate use. However, in production use it will be much more efficient
* to directly load just the components you need from the /define folder.
* 
* NOTE: Do not edit this file by hand. This file is generated during
* publishing, or you can regenerate it with \`npm run prepublishOnly\`.
*/`;

const tsHeader = `// TypeScript declarations for the complete Elix library.`;

async function createLibraryFile(
  destination,
  header,
  sourceFolder,
  sourceFiles
) {
  const destinationFolder = path.dirname(destination);
  const relativeFolder = path.relative(destinationFolder, sourceFolder);
  const classExportFiles = [
    ...sourceFiles.components,
    ...sourceFiles.mixins
  ].sort();

  const classExports = classExportFiles
    .map(file => {
      const name = path.basename(file, ".js");
      // Components point to the local folder, mixins point to /src/base.
      const isMixin = name.endsWith("Mixin");
      const filePath =
        isMixin && destinationFolder !== sourceFolder
          ? path.join(relativeFolder, file)
          : `../src/plain/${file}`;
      return `export { default as ${name} } from "${filePath}";`;
    })
    .join("\n");

  const helperFiles = sourceFiles.helpers;
  const helperExports = helperFiles
    .map(file => {
      const name = path.basename(file, ".js");
      // Helpers always point to the /src/base folder.
      const filePath =
        destinationFolder !== sourceFolder
          ? path.join(relativeFolder, file)
          : `../src/base/${file}`;
      return `import * as ${name}Import from "${filePath}";
// @ts-ignore
export const ${name} = ${name}Import;
`;
    })
    .join("\n");

  const content = `${header}

// Files that export a single object.
${classExports}

// Files that export multiple objects.
// As of Sept 2019, there's no way to simultaneously import a collection of
// objects and then export them as a named object, so we have to do the import
// and export in separate steps.
${helperExports}`;

  await fs.writeFile(destination, content);
}

async function createLibraryFiles(
  sourceFiles,
  destinationFolder,
  defineFolder
) {
  // Write library files to /src folder,
  // and auto-define variations to /define folder.
  const srcJsPath = path.join(destinationFolder, "elix.js");
  const srcTsPath = path.join(destinationFolder, "elix.d.ts");
  const defineJsPath = path.join(defineFolder, "elix.js");
  const defineTsPath = path.join(defineFolder, "elix.d.ts");
  await Promise.all([
    createLibraryFile(srcJsPath, srcJsHeader, destinationFolder, sourceFiles),
    createLibraryFile(srcTsPath, tsHeader, destinationFolder, sourceFiles),
    createLibraryFile(
      defineJsPath,
      defineJsHeader,
      destinationFolder,
      sourceFiles
    ),
    createLibraryFile(defineTsPath, tsHeader, destinationFolder, sourceFiles)
  ]);
}

module.exports = createLibraryFiles;
