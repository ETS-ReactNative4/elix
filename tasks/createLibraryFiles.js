// Create the top-level elix.js and elix.d.ts files.


const fs = require('fs').promises;
const path = require('path');


async function createLibraryFiles(sourceFiles) {

  const classExportFiles = [...sourceFiles.components, ...sourceFiles.mixins].sort();
  const srcClassExports = classExportFiles.map(file => {
    const name = path.basename(file, '.js');
    return `export { default as ${name} } from './${file}';`
  }).join('\n');

  const defineClassExports = classExportFiles.map(file => {
    const name = path.basename(file, '.js');
    const isMixin = name.endsWith('Mixin');
    const filePath = isMixin ?
      `../src/${file}` :
      `./${file}`;
    return `export { default as ${name} } from '${filePath}';`
  }).join('\n');

  const helperFiles = sourceFiles.helpers;
  const srcHelperExports = helperFiles.map(file => {
    const name = path.basename(file, '.js');
    return `import * as ${name}Import from './${file}';
// @ts-ignore
export const ${name} = ${name}Import;
`;
  }).join('\n');

  const defineHelperExports = helperFiles.map(file => {
    const name = path.basename(file, '.js');
    return `import * as ${name}Import from '../src/${file}';
// @ts-ignore
export const ${name} = ${name}Import;
`;
  }).join('\n');

  const srcJsSource =
`/*
 * The complete set of Elix elements and mixins.
 * 
 * This file is the primary entry point to the Elix package, so its exports are
 * what is obtained if you write \`import * from 'elix'\`. However, in
 * production use it will be much more efficient to directly load just the
 * components you need from the /src folder. This file is also used during
 * testing, as it causes all Elix's elements to be loaded.
 * 
 * NOTE: Do not edit this file by hand. This file is generated during
 * publishing, or you can regenerate it with \`npm run prepublishOnly\`.
 */

// Files that export a single object.
${srcClassExports}

// Files that export multiple objects.
// As of Sept 2019, there's no way to simultaneously import a collection of
// objects and then export them as a named object, so we have to do the import
// and export in separate steps.
${srcHelperExports}`;

  const defineJsSource =
`/*
* The complete set of Elix elements and mixins.
* 
* You can load this file as a convenience to auto-define all Elix components
* for immediate use. However, in production use it will be much more efficient
* to directly load just the components you need from the /define folder.
* 
* NOTE: Do not edit this file by hand. This file is generated during
* publishing, or you can regenerate it with \`npm run prepublishOnly\`.
*/

// Files that export a single object.
${defineClassExports}

// Files that export multiple objects.
// As of Sept 2019, there's no way to simultaneously import a collection of
// objects and then export them as a named object, so we have to do the import
// and export in separate steps.
${defineHelperExports}
`;

  const tsSource =
`// TypeScript declarations for the complete Elix library.

// Files that export a single object.
${srcClassExports}

// Files that export multiple objects.
// As of Sept 2019, there's no way to simultaneously import a collection of
// objects and then export them as a named object, so we have to do the import
// and export in separate steps.
${srcHelperExports}`;

  // Write library files to /src folder,
  // and auto-define variations to /define folder.
  const srcJsPath = path.join(__dirname, '../src/elix.js');
  const srcTsPath = path.join(__dirname, '../src/elix.d.ts');
  const defineJsPath = path.join(__dirname, '../define/elix.js');
  const defineTsPath = path.join(__dirname, '../define/elix.d.ts');

  await Promise.all([
    fs.writeFile(srcJsPath, srcJsSource),
    fs.writeFile(srcTsPath, tsSource),
    fs.writeFile(defineJsPath, defineJsSource),
    fs.writeFile(defineTsPath, tsSource)
  ]);
}


module.exports = createLibraryFiles;
